----------------------------------------------------------------------
h1. Configuration

h3. Buts

* Configurer git pour qu'il soit prêt à être utilisé.

h2. Configurer son nom et son email

p. Si vous n'avez jamais utilisé git avant, vous allez devoir faire quelques
paramétrages d'abord.
Lancer les commandes suivantes pour que git connaisse votre nom et votre email.
Si vous avez déjà configuré git, vous pouvez passez plus bas à la partie sur
les fins de ligne.

execute:
git config --global user.name "Your Name"
git config --global user.email "your_email@whatever.com"

h2. Paramétrer les préférences du type de fin de lignes

Aussi, pour les utilisateurs Unix/Mac:

execute:
git config --global core.autocrlf input
git config --global core.safecrlf true

Et pour les utilisateurs Windows:

execute:
git config --global core.autocrlf true
git config --global core.safecrlf true

----------------------------------------------------------------------
h1. Configuration supplémentaire

h3. Buts

* Avoir le matériel pour le tutoriel paramétré et prêt à être utilisé.

h2. Obtenir le paquet pour le tutoriel.

p. Télécharger le paquet pour le tutoriel depuis:

* L'URL "http://gitimmersion.com/git_tutorial.zip":http://gitimmersion.com/git_tutorial.zip

h2. Dézipper le tutoriel

p. Le paquet pour le tutoriel doit contenir un répertoire principal "git_tutorial"
avec trois sous-répertoires:

* html -- Ces fichiers html.  Lancer votre navigateur depuis html/index.html
* work -- Un répertoire de travail vide.  Créer votre dépôt dedans.
* repos -- Dépôts Git préparés pour vous permettre d'avancer dans le tutoriel
en partant de n'importe quelle étape.  Si vous êtes bloqué, copier juste le
dépôt souhaité dans votre répertoire de travail.

----------------------------------------------------------------------
h1. Créer un projet

h3. Buts

* Apprendre à créer un dépôt git à partir de rien.

h2. Créer un programme "Hello, World"

p. En commençant dans le répertoire de travail vide, créer un répertoire vide
nommé "hello", ensuite créer un fichier nommé @hello.rb@ avec le contenu
ci-dessous.

Execute:
mkdir hello
cd hello

File: hello.rb
puts "Hello, World"
EOF

h2. Créer le dépôt

p. Vous avez maintenant un répertoire avec un fichier unique. Pour créer une
dépôt git depuis ce répertoire, lancer la commande git init.

Execute:
git init
=init
+git config user.name "Jim Weirich"
+git config user.email "jim (at) edgecase.com"

Output:
=init
EOF

h2. Ajouter le programme au dépôt

Maintenant ajoutons le fichier du programme "Hello, World" au dépôt.

Execute:
git add hello.rb
=add
git commit -m "First Commit"
=commit

p. Vous devriez voir ...

Output:
=add
=commit
EOF

----------------------------------------------------------------------
h1. Vérifier le status

h3. Buts

* Apprendre comment vérifier le statut du dépôt

h2. Vérifier le status du dépôt

p. Utiliser la commande @git status@ pour vérifier le statut de votre dépôt.


Execute:
git status
=status

p. Vous devriez voir

Output:
=status
EOF

p. La commande status renvoie qu'il n'y a rien à commiter. Cela
signifie que le dépôt a l'état complet du répertoire de travail.
Il n'y a pas de changements signalés comme à enregistrer.

p. Nous allons utiliser la commande @git status@ pour continuer à suivre
l'état entre le dépôt et le répertoire de travail.

----------------------------------------------------------------------
h1. Effectuer des changements

h3. Buts

* Apprendre comment suivre l'état du répertoire de travail

h2. Changer le programme "Hello, World".

p. Il est temps de changer notre programme hello pour lui passer un argument
depuis la ligne de commande. Changer le fichier pour qu'il soit:

File: hello.rb
puts "Hello, #{ARGV.first}!"
EOF

h2. Vérifier le status

p. Maintenant vérifier le statut de du répertoire de travail.

Execute:
!git status
=status

p. Vous devriez voir ...

Output:
=status
EOF

p. La première chose à constater est que git sait que le fichier @hello.rb@
a été modifié, mais que git n'a pas encore averti de ces changements.

p. Noter également que le message de status vous guide sur ce que vous alles
devoir faire par la suite. Si vous voulez ajouter ces changements au répertoire,
alors utiliser la commande @git add@. Dans le cas contraire, la commande
@git checkout@ peut être utilisé pour annuler les changements.

h2. Up Next

p. Let's stage the change.

----------------------------------------------------------------------
h1. Déclarer les changements

h3. Buts

* Apprendre à déclarer les changements pour les commits à venir

h2. Ajouter les changements

p. Maintenant indiquer à git de prendre en compte les changements déclarés. Vérifier le status

Execute:
git add hello.rb
=add
git status
=status

p. Vous devriez voir ...

Output:
=add
=status
EOF

p. Le changement sur le fichier @hello.rb@ a été déclaré. Cela signifie
que git est informé du changement, mais le changement n'a pas pas encore
eté enregistré de manière _permanente_ dans le dépôt. La prochaine opération
de commit inclura les changements qui ont été déclarés.

p. Si vous décidez que vous _ne_ voulez pas commiter ce changement après tout,
la commande de status vous rappelle que la commande @git reset@ peut être
utilisée pour annuler cet déclaration de ce changement.

----------------------------------------------------------------------
h1. Déclarer et commiter

p. Une étape de déclaration des fichiers séparée depuis git est en rapport
avec la philosophie de ne pas être bloqué tant que vous n'avez pas besoin
d'utiliser un gestionnaire de version.
Vous pouvez continuer à faire des changements dans votre répertoire de travail
et ensuite, lorsque vous devez commencer à utiliser le gestion de version, git
vous permet d'enregistrer vos changements dans de petits commits qui
enregistrent exacteemnt ce que vous avez fait.

p. Par exemple, supposons que vous éditiez trois fichiers (@a.rb@, @b.rb@, et
@c.rb@). Maintenant vous voulez commiter tous les changements, mais vous voulez
que les changements dans @a.rb@ et @b.rb@ soit dans un seul commit et que ceux
dans @c.rb@uuu sans rapport logique avec les deux premiers fichiers soit dans
 une commit séparé.

p. Vous pourriez faire:

pre(instructions).
git add a.rb
git add b.rb
git commit -m "Changes for a and b"

pre(instructions).
git add c.rb
git commit -m "Unrelated change to c"

p. En séparant la déclaration du commit, vous avez la possibilité de
choisir précisément et facilement ce que vous ajoutez à chaque commit.

----------------------------------------------------------------------
h1. Commiter les changements

h3. Buts

* Apprendre à commiter les changements au dépôt

h2. Commiter le changement

p. Ok, assez avec la déclaration.  Maintenant commitons ce que nous avons
déclaré dans le répertoire.

p. Quand vous avez utilisé @git commit@ précédemment pour commiter la version
initiale du fichier @hello.rb@ dans le dépôt, vous avez inclus l'indicateur @-m@
qui renvoie un commentaire dans la ligend de commande. La commande de commit va
vous permettre d'éditer un commentaire de manière interactive pour le commit.
Essayons maintenant.

p. Si vous oubliez l'indicateur @-m@ depuis la ligne de commande, git va vous
ouvrir l'éditeur de texte de votre choix. Cet éditeur est choisi en s'appuyant
sur la liste suivante (avec par ordre de priorité):

* la variable d'environnement GIT_EDITOR
* le paramètre de configuration core.editor
* la variable d'environnement VISUAL
* la variable d'environnement EDITOR

p. J'ai la variable EDITOR définie à @emacsclient@.

p. Ainsi commitons maintenant et vérifions le status.

Execute:
-git commit
+git commit -m "Using ARGV"

p. You should see the following in your editor:

Output:
|
# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#	modified:   hello.rb
#
EOF

p. Sur la première ligne, entrer le commentaire: "Using ARGV".  Sauver le
fichier et sortir de l'éditeur. Vous devriez voir ...

Output:
git commit
Waiting for Emacs...
[master 569aa96] Using ARGV
 1 files changed, 1 insertions(+), 1 deletions(-)
EOF

p. La ligne "Waiting for Emacs..." vient du programme @emacsclient@ qui envoie
le fichier au programme dmacs et attend que le fichier soit fermé. Le reste de
la sortie est constitué des messages standards pour un commmit
messages.

h2. Vérifier le status

p. Finalement essayons de vérifier le status encore.

Execute:
!git status
=status

Vous devriez voir ...

Output:
=status
EOF

p. Le répertoire de travail est propre et prêt pour que vous continuiez.

----------------------------------------------------------------------
h1. Changements, pas fichiers

h3. Buts

* Apprendre que git fonctionne avec les changements, pas avec les fichiers.

p. La plupart des logiciels de gestion de version travaillent avec des
fichiers. Vous ajoutez un fichier à la source versionnée et le sytème suivra
les changements que vous effectuez dessus à partir de ce moment.

p. Git se concentre sur les changements dans un fichier plutôt que sur le
fichier en lui même.
Quand vous faites @git add file@, vous ne dites pas à git d'ajouter le fichier
au dépôt. Vous dites plutôt que git devrait prendre en compte la situation de
ce fichier pour qu'il soit commité plus tard.

p. Nous allons chercher à vous faire explorer cette différence dans cette
partie.

h2. Premier changement: autoriser un nom de fichier par défaut

p. Changer le programme "Hello, World" pour avoir une valeur par défault si un
argument est passé en ligne en commande si il n'est pas supplié.

File: hello.rb
name = ARGV.first || "World"

puts "Hello, #{name}!"
EOF

h2. Rajouter ce changement

p. Maintenant ajouter ce changement dans la déclaration des fichiers de git.

Execute:
git add hello.rb

h2. Deuxième changement: ajouter une commentaire

p. Maintenant ajouter un commentaire au programme "Hello, World".

File: hello.rb
# Default is "World"
name = ARGV.first || "World"

puts "Hello, #{name}!"
EOF

h2. Vérifier le status courant

Execute:
!git status
=status

p. Vous devriez voir ...

Output:
=status
EOF

p. Remarquer comment @hello.rb@ est listé deux fois dans le status. Le premier
changement (ajouter une valeur par défaut) est déclarée et est prête à être commité.
Le second changement (ajouter un commentaire) n'est pas déclaré. Si vous deviez
commiter dès maintenant, le commentaire ne serait pas sauvé dans le dépôt.

p. Maintenant essayons cela.

h2. Commiter

p. Commiter le changement déclaré (la valeur par défaut), et ensuite revérifions le status.

Execute:
git commit -m "Added a default value"
=commit
git status
=status2

p. Vous devriez voir ...

Output:
=commit
=status2
EOF

p. La commande de status vous dis que @hello.rb@ a des changements non enregistrés,
mais n'est plus dans la liste des fichiers déclarés.

h2. Ajouter le second changement

p. Maintenant ajouter le second changement à la liste des fichiers déclarés,
ensuite lancer git status.

Execute:
git add .
!git status
=status3

p(note). *Note:* Nous utilisons le répertoire courrant ('.') comme le
fichier à ajouter. C'est vraiment un raccourci pratique pour ajouter tous
les changements au fichiers dans le répertoire courant et en dessous. Mais
comme il ajoute tout, c'est _vraiment_ une bonne idée de vérifier le status
avant de faire un <tt>add .</tt>, juste pour s'assurer que vous n'ajoutez aucun
fichier qui ne soit pas désiré.

p(note). Je voulais que voyiez l'astuce "add .", mais nous allons continuer
à ajouter explicitement les fichiers dans le reste du tutoriel juste pour
être sûr.

p. Vous devriez voir ...

Output:
=status3
EOF

p. Maintenant le second changement a été déclaré et est prêt à être commité.

h2. Commiter le second changement

Execute:
git commit -m "Added a comment"

----------------------------------------------------------------------
h1. Historique

h3. Buts

* Apprendre comment voir l'historique du projet.

p. Avoir une liste des changements qui ont été effectués est le rôle de la
commande @git log@.

Execute:
git log
=log

p. Vous devriez voir ...

Output:
=log
EOF

p. Voici la liste des quatre commits que nous avons fait dans le dépôt
jusqu'à maintenant.

h2. Historique avec entrées sur une ligne

p. Vous avez une grande possibilité de contrôle sur ce que la commande @log@
renvoie. J'aime bien le formatage sur une ligne:

Execute:
git log --pretty=oneline
=oneline

p. Vous devriez voir ...

Output:
=oneline
EOF

h2. Contrôler quelles entrées sont affichées

p. Il y a beaucoup d'options pour sélectionner quelles entrées sont
affichées dans le log. Jouez avec les commandes suivantes:

pre(instructions).
git log --pretty=oneline --max-count=2
git log --pretty=oneline --since='5 minutes ago'
git log --pretty=oneline --until='5 minutes ago'
git log --pretty=oneline --author=<your name>
git log --pretty=oneline --all

p. Voir man git-log pour tous les détails.

h2. Devenir imaginatif

p. Voici ce que j'utilise pour vérifier les changements fait dans la dernière semaine.
J'ajouterai @--author=jim@ si je veux seulement les changements que j'ai fait.

pre(instructions).
git log --all --pretty=format:"%h %cd %s (%an)" --since='7 days ago'

h2. Le formatage de fichier de log ultime

p. Au fil du temps, j'ai décidé que j'aimais le formatage de log suivant
pour la plupart de mon travail.

Execute:
git log --pretty=format:"%h %ad | %s%d [%an]" --graph --date=short
=ultimate

Cela ressemble à:

Output:
=ultimate
EOF

p. Regardons cette ligne dans le détail:

* @--pretty="..."@ définit le format de sortie.
* @%h@ est la hash abrégé du commit
* @%d@ sont le type de décoration sur ce commit (comme les branches ou les tags)
* @%ad@ est la date de l'auteur
* @%s@ est le commentaire
* @%an@ est le nom de l'auteur
* @--graph@ informe git d'afficher l'arbre de commit dans un rendu de type graphe ASCII
* @--date=short@ garde le format de la date joli et court

p. C'est beaucoup à taper chaque fois que vous voulez voir le log.
Heuseusement nous apprendrons à utiliser les alias git dans la prochaine partie.

h2. Autres outils

p. Les deux <code>gitx</code> (pour Macs) et <code>gitk</code> (chaque plateforme)
sont utile pour exlorer l'historique des logs.

----------------------------------------------------------------------
h1. Alias

h3. Buts

* Apprendre comment paramétrer les alias et les raccourcis pour les commandes git

h2. Alias communs

p. +git status+, +git add+, +git commit+, et +git checkout+ sont ces
commandes habituelles dont il est utile d'avoir des abbréviations.

p. Ajouter ce qui suit dans le fichier .gitconfig dans votre répertoire $HOME.

file: .gitconfig
[alias]
  co = checkout
  ci = commit
  st = status
  br = branch
  hist = log --pretty=format:\"%h %ad | %s%d [%an]\" --graph --date=short
  type = cat-file -t
  dump = cat-file -p
EOF

p. Nous avons couverts checkout, commit et status. Et nous avons aussi
couvert la commande @log@ dans la précédente partie. Maintenant vous
pouvez taper @git co@ à la place de taper @git checkout@. De la même manière
@git st@ pour @git status@ et @git ci@ pour @git commit@. Et le meilleur de
tous, @git hist@ vous permettra d'éviter la très longue commande @log@.

p. Continuez et faites quelques essais pour essayer.

h2. Définir l'alias @hist@ dans votre fichier @.gitconfig@

p. Pour la plupart des cas, je continuerais à taper les commandes complètes
dans les instructions. La seule exception est que j'utiliserais l'alias @hist@
défini ci-dessus chaque fois que vous avez besoin de voir la sortie de log git.
Assurer vous d'avoir un alias @hist@ configuré dans votre fichier @.gitconfig@
avant de continuer le tutoriel suivant.

h2. @Type@ et @Dump@

p. Nous avons déjà ajouté quelques alias pour des commandes que nous n'avons
pas encore abordé. La commande @git branch@ va bientôt être abordée. et la
commande @git cat-file@ est utile pour explorer git, ce que nous verrons dans
un petit moment.

h2. Alias de la ligne de commande (optionnel)

p(note). *Note:* Cette section est pour les utilisateurs qui utilisent une ligne
de commande de type posix. Les utilisateurs Windows et utilisateurs n'utilisant pas
une ligne de commande non-posix peuvent passer à la prochaine partie.

p. Si votre ligne de commande supporte les alias et les raccourcis, ensuite vous
pouvez utiliser des alias à ce niveau également. Voici ceux que j'utilise:

file: .profile
alias gs='git status '
alias ga='git add '
alias gb='git branch '
alias gc='git commit'
alias gd='git diff'
alias go='git checkout '
alias gk='gitk --all&'
alias gx='gitx --all'

alias got='git '
alias get='git '
EOF

p. L'abbréviation @go@ pour @git checkout@ est particulièrement joli. Cela me
permet de taper:

pre(instructions). go <branch>

p. pour récupérer une branche particulière.

p. Et oui, je tape par erreur @git@ comme @get@ ou @got@ suffisamment souvent
pour créer l'alias pour eux.

----------------------------------------------------------------------
h1. Obtenir de vieille versions

h3. Buts

* Apprendre comment récupérer n'importe quelle état du dépôt dans le répertoire
de travail.

p. Retourner dans l'historique est très facile. La comande checkout va copier
n'importe quel état depuis le dépôt vers le répertoire de travail.

h2. Obtenir les hashs pour les précédentes versions

Execute:
git hist
=log

p(note). *Note:* Vous vous rappelez avoir défini @hist@ dans votre
fichier @.gitconfig@, n'est ce pas? Si ce n'est pas le cas, revoyez le tutoriel
sur les alias.

Output:
=log
EOF

p. Examiner la sortie du log et trouver le hash pour le premier commit. Cela
doit être la dernière ligne de la sortie de @git hist@. Utiliser le code hash
(les 7 premiers caractères sont suffisants) dans la commande ci-dessous. Ensuite,
vérifier le contenu du fichier hello.rb.

Set: hash=hash_for("First Commit")
Execute:
git checkout <hash>
=checkout
cat hello.rb
=cat

p(note). *Note:* Les commandes données ici sont des commandes Unix et
fonctionnent à la fois sous Mac et Linux. Malheureusement, les utilisateurs Windows
devront traduire pour leur ligne de commande propre (DOS).

p(note). *Note:* De nombreuses commandes dépendent des valeurs de hash
dans le dépôt. Comme vos valeurs de hash vont changer des miennes, chaque fois que
vous voyez quelque chose comme &lt;hash&gt; ou &lt;treehash&gt; dans la commande,
remplacer la valeur par votre propre valeur de dépôt.

p. Vous devriez voir ...

Output:
=checkout
=cat
EOF

p. La sortie de la commande @checkout@ explique la situation de manière assez
claire. Les vieilles versions de git vont se plaindre de ne pas être sur une
branche locale. Dans tous les cas, ne vous en inquiétez pas maintenant.

p. Noter que les contenus du fichier hello.rb sont les contenus originaux.

h2. Retourner la dernière version de la branche master

Execute:
git checkout master
=checkout2
cat hello.rb
=cat2

p. Vous devriez voir ...

Output:
=checkout2
=cat2
EOF

p. 'master' est le nom de la branche par défaut. En faisant un "checkout"
sur une branche, vous avez la dernière version de cette branche.

----------------------------------------------------------------------
h1. Tagger des versions

h3. Buts

* Apprendre comment tagger des commits avec des noms pour des références futures

p. Appelons la version courante du programme hello version 1 (v1).

h2. Tagger la version 1

Execute:
git tag v1
=tag

p. Maintenant vous pouvez vous référer à la version courante du programme comme v1.

h2. Tagger des versions précédentes

p. Taggons immédiatement la première version précédente à la version courante sous
le nom v1-beta.  D'abord, nous devons revenir à la version précédente. Plutôt que
d'utiliser le hash, nous allons utilise la notation @^@ pour indiquer "le parent
de v1".

p(note). Si la notation @v1@^ vous cause un problème, vous pouvez aussi essayer
@v1~1@, qui référencera la même version. Cette notation signifie le "premier
ancêtre de v1".

Execute:
git checkout v1^
=checkout
cat hello.rb
=cat

Output:
=checkout
=cat
EOF

p. Voir que c'est la version avec la valeur par défault _avant_ que nous ajoutions
le commentaire. Faisons cette v1-beta.

Execute:
git tag v1-beta

h2. Récupérer par nom de tag

p. Maintenant essayons de passer d'une version taggée à l'autre et inversement.

Execute:
git checkout v1
=cov1
git checkout v1-beta
=cov1beta

Output:
=cov1
=cov1beta
EOF

h2. Voir les tags en utilisant la commande @tag@

p. Vous pouvez voir quels tags sont disponibles en utilisant la commande @git tag@.

Execute:
git tag
=tag2

Output:
=tag2
EOF

h2. Voir les tags dans les logs

p. Vous pouvez aussi vérifier les tags dans le log.

Execute:
git hist master --all
=hist

Output:
=hist
EOF

p. Vous pouvez voir les deux tags (@v1@ et @v1-beta@) listé dans la sortie
de log, avec à côté le nom de la branche (@master@).  Aussi, @HEAD@ vous
montre le commit qui est actuellement utilisé (qui est le @v1-beta@ pour
le moment).

----------------------------------------------------------------------
h1. Annuler les changements locaux (avant les déclarations)

h3. Buts

* Apprendre comment revenir sur les changements dans votre répertoire de travail

h2. Repasser sur la branche master

p. S'assurer que vous êtes sur le dernier commit dans master avant de continuer.

Execute:
git checkout master

h2. Changer hello.rb

p. Quelquefois, vous avez modifié un fichier dans votre répertoire de travail local
et vous souhaitez simplement revenir à l'état de ce qui a été déjà commité. La
commande checkout va gérer cela.

Changer hello.rb pour avoir un mauvais commentaire.

File: hello.rb
# This is a bad comment.  We want to revert it.
name = ARGV.first || "World"

puts "Hello, #{name}!"
EOF

h2. Vérifier le status

p. En premier, vérifier le status du répertoire de travail.

Execute:
!git status
=status

Output:
=status
EOF

p. Nous voyons que le fichier @hello.rb@ a été modifié mais n'a pas encore été déclaré.

h2. Annuler les changements dans le répertoire de travail

p. Utiliser la commande @checkout@ pour récupérer la version du fichier @hello.rb@ issue
du dépôt.

Execute:
git checkout hello.rb
=checkout
!git status
=status2
cat hello.rb
=cat

Output:
=checkout
=status2
=cat
EOF

p. La commande status nous montre qu'il n'y a plus de changements indiqués
dans le répertoire de travail. Et le "mauvais commentaire" n'est plus dans
le contenu du fichier.

----------------------------------------------------------------------
h1. Annuler les déclarations de fichiers changés (avant de commiter)

h3. Buts

* Apprendre comment annuler des changements qui ont déjà été déclarés

h2. Changer le fichier et déclarer le changement

p. Modifier le fichier @hello.rb@ pour avoir un mauvais commentaire

File: hello.rb
# This is an unwanted but staged comment
name = ARGV.first || "World"

puts "Hello, #{name}!"
EOF

p. Et maintenant continuer et déclarer le fichier.

Execute:
git add hello.rb

h2. Vérifier le status

p. Vérifier le status de votre changement non désiré.

Execute:
git status
=status

Output:
=status
EOF

p. La sortie du status montre que le changement a été déclaré et qu'il
est prêt à être commité.

h2. Réinitialiser la liste des fichiers déclarés

p. Heureusement la ligne de status nous dit exactement comment faire pour
annuler la déclaration du changement.

Execute:
git reset HEAD hello.rb
=reset

Output:
=reset
EOF

p. La commande @reset@ réinitialise la liste des fichiers déclarés à celle
qui est dans HEAD. Cela nettoye la liste des fichiers déclarés du changement
que nous venions juste de déclarer.

p. La commande @reset@ (par défaut) ne change pas le répertoire de travail
courant. Ainsi le répertoire de travail a toujours le commentaire non souhaité.
Nous pouvons utiliser la commande @checkout@ de la précédente partie pour enlever
la changement non désiré du répertoire de travail.

h2. Mettre à jour à la version commitée

Execute:
git checkout hello.rb
git status
=status2

Output:
=status2
EOF

p. Et notre répertoire de travail est propre à nouveau.

----------------------------------------------------------------------
h1. Annuler les changements déjà commités

h3. Buts

* Apprendre comment annuler revenir sur les changements qui ont déjà
été commités sur le dépôt local.

h2. Undoing Commits

p. Sometimes you realized that a change that you have already
committed was not correct and you wish to undo that commit.  There are
several ways of handling that issue, and the way we are going to use
in this lab is always safe.

p. Essentially we will undo the commit by creating a new commit that
reverses the unwanted changes.

h2. Change the file and commit it.

p. Change the @hello.rb@ file to the following.

File: hello.rb
# This is an unwanted but committed change
name = ARGV.first || "World"

puts "Hello, #{name}!"
EOF

Execute:
git add hello.rb
git commit -m "Oops, we didn't want this commit"

h2. Create a Reverting Commit

p. To undo a committed change, we need to generate a commit that
removes the changes introduced by our unwanted commit.

Execute:
-git revert HEAD
+git revert HEAD --no-edit
=revert

p. This will pop you into the editor.  You can edit the default commit
message or leave it as is.  Save and close the file. You should see ...

Output:
=revert
EOF

p. Since we were undoing the very last commit we made, we were able to
use @HEAD@ as the argument to revert.  We can revert any arbitrary
commit earlier in history by simply specifying its hash value.

p(note). *Note:* The @--no-edit@ in the output can be ignored.
It was necessary to generate the output without opening the editor.

h2. Check the log

p. Checking the log shows both the unwanted and the reverting commits
in our repository.

Execute:
git hist
=hist

Output:
=hist
EOF

p. This technique will work with any commit (although you may have to
resolve conflicts).  It is safe to use even on branches that are
publicly shared on remote repositories.

h2. Up Next

p. Next, let's look at a technique that can be used to remove the most
recent commits from the repository history.

----------------------------------------------------------------------
h1. Removing Commits from a Branch

h3. Goals

* Learn how to remove the most recent commits from a branch

p. The @revert@ command of the previous section is a powerful command
that lets us undo the effects of any commit in the repository.
However, both the original commit and the "undoing" commit are visible
in the branch history (using the @git log@ command).

p. Often we make a commit and immediately realize that it was a
mistake.  It would be nice to have a "take back" command that would
allow us to pretend that the incorrect commit never happened.  The
"take back" command would even prevent the bad commit from showing up
the @git log@ history.  It would be as if the bad commit never
happened.

h2. The @reset@ command

p. We've already seen the @reset@ command and have used it to set the
staging area to be consistent with a given commit (we used the HEAD
commit in our previous lab).

p. When given a commit reference (i.e. a hash, branch or tag name),
the @reset@ command will ...

# Rewrite the current branch to point to the specified commit
# Optionally reset the staging area to match the specified commit
# Optionally reset the working directory to match the specified commit

h2. Check Our History

p. Let's do a quick check of our commit history.

Execute:
git hist
=hist

Output:
=hist
EOF

p. We see that we have an "Oops" commit and a "Revert Oops" commit as
the last two commits made in this branch.  Let's remove them using
reset.

h2. First, Mark this Branch

p. But before we remove the commits, let's mark the latest commit with
a tag so we can find it again.

Execute:
git tag oops

h2. Reset to Before Oops

p. Looking at the log history (above), we see that the commit tagged
'v1' is the commit right before the bad commit.  Let's reset the
branch to that point.  Since that branch is tagged, we can use the tag
name in the reset command (if it wasn't tagged, we could just use the
hash value).

Execute:
git reset --hard v1
=reset
git hist
=hist2

Output:
=reset
=hist2
EOF

p. Our master branch now points to the v1 commit and the Oops commit
and the Revert Oops commit are no longer in the branch.  The @--hard@
parameter indicates that the working directory should be updated to be
consistent with the new branch head.

h2. Nothing is Ever Lost

p. But what happened to the bad commits?  It turns out that the
commits are still in the repository.  In fact, we can still reference
them.  Remember that at the beginning of this lab we tagged the
reverting commit with the tag "oops".  Let's look at _all_ the commits.

Execute:
git hist --all
=hist3

Output:
=hist3
EOF

p. Here we see that the bad commits haven't disappeared.  They are
still in the repository.  It's just that they are no longer listed in
the master branch.  If we hadn't tagged them, they would still be in
the repository, but there would be no way to reference them other than
using their hash names.  Commits that are unreferenced remain in the
repository until the system runs the garbage collection software.

h2. Dangers of Reset

p. Resets on local branches are generally safe.  Any "accidents" can
usually be recovered from by just resetting again with the desired
commit.

p. However, if the branch is shared on remote repositories, resetting
can confuse other users sharing the branch.

----------------------------------------------------------------------
h1. Remove the oops tag

h3. Goals

* Remove the oops tag (housekeeping)

h2. Removing tag oops

p. The oops tag has served its purpose.  Let's remove it and allow the
commits it referenced to be garbage collected.

Execute:
git tag -d oops
=tag
git hist --all
=hist

Output:
=tag
=hist
EOF

p. The oops tag is no longer listed in the repository.

----------------------------------------------------------------------
h1. Amending Commits

h3. Goals

* Learn how to amend an existing commit

h2. Change the program then commit

p. Add an author comment to the program.

File: hello.rb
# Default is World
# Author: Jim Weirich
name = ARGV.first || "World"

puts "Hello, #{name}!"
EOF

Execute:
git add hello.rb
git commit -m "Add an author comment"

h2. Oops, Should have an Email

p. After you make the commit, you realize that any good author comment
should have an email included.  Update the hello program to include an
email.

File: hello.rb
# Default is World
# Author: Jim Weirich (jim@somewhere.com)
name = ARGV.first || "World"

puts "Hello, #{name}!"
EOF

h2. Amend the Previous Commit

p. We really don't want a separate commit for just the email.  Let's
amend the previous commit to include the email change.

Execute:
git add hello.rb
=add
git commit --amend -m "Add an author/email comment"
=commit

Output:
=add
=commit
EOF


h2. Review the History

Execute:
git hist
=hist

Output:
=hist
EOF

p. We can see the original "author" commit is now gone, and it is
replaced by the "author/email" commit.  You can achieve the same
effect by resetting the branch back one commit and then recommitting
the new changes.

----------------------------------------------------------------------
h1. Moving Files

h3. Goals

* Learn how to move a file within a repository.

h2. Move the hello.rb file into a lib directory.

p. We are now going to build up the structure of our little
repository.  Let's move the program into a lib directory.

Execute:
mkdir lib
=mkdir
git mv hello.rb lib
=move
!git status
=status

Output:
=mkdir
=move
=status
EOF

p. By using git to do the move, we inform git of 2 things

# That the file @hello.rb@ has been deleted.
# The file @lib/hello.rb@ has been created.

p. Both of these bits of information are immediately staged and ready
to be committed.  The git status command reports that the file has been
moved.

h2. Another way of moving files

p. One of the nice things about git is that you can forget about
source control until the point you are ready to start committing code.
What would happen if we used the operating system command to move the
file instead of the git command?

p. It turns out the following set of commands is identical to what we
just did.  It's a bit more work, but the result is the same.

p(command). We could have done:

pre(instructions). mkdir lib
mv hello.rb lib
git add lib/hello.rb
git rm hello.rb

h2. Commit the new directory

p. Let's commit this move.

Execute:
git commit -m "Moved hello.rb to lib"

----------------------------------------------------------------------
h1. More Structure

h3. Goals

* Add another file to our repository

h2. Now add a Rakefile

p. Let's add a Rakefile to our repository.  The following one will do
nicely.

File: Rakefile
#!/usr/bin/ruby -wKU

task :default => :run

task :run do
  require './lib/hello'
end
EOF

p. Add and commit the change.

Execute:
git add Rakefile
git commit -m "Added a Rakefile."

p. You should be able to use Rake to run your hello program now.

Execute:
rake
=rake

Output:
=rake
EOF

----------------------------------------------------------------------
h1. Git Internals: The .git directory

h3. Goals

* Learn about the structure of the @.git@ directory

h2. The @.git@ Directory

p. Time to do some exploring.  First, from the root of your project
directory...

Execute:
ls -C .git
=lsgit

Output:
=lsgit
EOF

p. This is the magic directory where all the git "stuff" is stored.
Let's peek in the objects directory.

h2. The Object Store

Execute:
ls -C .git/objects
=lsobjs

Output:
=lsobjs
EOF

p. You should see a bunch of directories with 2 letter names.  The
directory names are the first two letters of the sha1 hash of the
object stored in git.

h2. Deeper into the Object Store

Set: dir=`ls .git/objects | head -1`.strip
Execute:
ls -C .git/objects/<dir>
=lsobjs2

Output:
=lsobjs2
EOF

p. Look in one of the two-letter directories.  You should see some
files with 38-character names.  These are the files that contain the
objects stored in git.  These files are compressed and encoded, so
looking at their contents directly won't be very helpful, but we will
take a closer look in a bit.

h2. Config File

Execute:
cat .git/config
=cat

Output:
=cat
EOF

p. This is a project-specific configuration file.  Config entries in
here will override the config entries in the @.gitconfig@ file in your
home directory, at least for this project.

h2. Branches and Tags

Execute:
ls .git/refs
=refs
ls .git/refs/heads
=refhead
ls .git/refs/tags
=reftags
cat .git/refs/tags/v1
=refv1

Output:
=refs
=refhead
=reftags
=refv1
EOF

p. You should recognize the files in the tags subdirectory.  Each file
corresponds to a tag you created with the @git tag@ command earlier.
Its content is just the hash of the commit tied to the tag.

p. The heads directory is similar, but is used for branches rather
than tags.  We only have one branch at the moment, so all you will see
is master in this directory.

h2. The HEAD File

Execute:
cat .git/HEAD
=head

Output:
=head
EOF

p. The HEAD file contains a reference to the current branch.  It
should be a reference to master at this point.

----------------------------------------------------------------------
h1. Git Internals: Working directly with Git Objects

h3. Goals

* Explore the structure of the object store
* Learn how to use the SHA1 hashes to find content in the repository

p. Now let's use some tools to probe git objects directly.

h2. Finding the Latest Commit

Execute:
git hist --max-count=1
=log

p. This should show the latest commit made in the repository.  The
SHA1 hash on your system is probably different that what is on mine,
but you should see something like this.

Output:
=log
EOF

h2. Dumping the Latest Commit

Using the SHA1 hash from the commit listed above ...

Set: hash=hash_for("Added a Rakefile")
Execute:
git cat-file -t <hash>
=type
git cat-file -p <hash>
=dump

Here's my output ...

Output:
=type
=dump
EOF

p(note). *NOTE:* If you defined the 'type' and 'dump' aliases from
the aliases lab, then you can type @git type@ and @git dump@ rather
than the longer cat-file commands (which I never remember).

p. This is the dump of the commit object that is at the head of the
master branch.  It looks a lot like the commit object from the
presentation earlier.

h2. Finding the Tree

p. We can dump the directory tree referenced in the commit.  This
should be a description of the (top level) files in our project (for
that commit).  Use the SHA1 hash from the "tree" line listed above.

Set: treehash=hash_in(var['hash'], 'tree')
Execute:
git cat-file -p <treehash>
=treedump

p. Here's what my tree looks like...

Output:
=treedump
EOF

p. Yep, I see the Rakefile and the lib directory.

h2. Dumping the lib directory

Set: libhash=hash_in(var['treehash'], 'lib')
Execute:
git cat-file -p <libhash>
=libdump

Output:
=libdump
EOF

p. There's the @hello.rb@ file.

h2. Dumping the @hello.rb@ file

Set: rbhash=hash_in(var['libhash'], 'hello')
Execute:
git cat-file -p <rbhash>
=rbdump

Output:
=rbdump
EOF

p. There you have it.  We've dumped commit objects, tree objects and
blob objects directly from the git repository.  That's all there is to
it, blobs, trees and commits.

h2. Explore On You Own

p. Explore the git repo manually on your own.  See if you can find the
original hello.rb file from the very first commit by manually
following the SHA1 hash references starting in the latest commit.

----------------------------------------------------------------------
h1. Creating a Branch

h3. Goals

* Learn how to create a local branch in a repository

p. It's time to do a major rewrite of the hello world functionality.
Since this might take awhile, you'll want to put these changes into a
separate branch to isolate them from changes in master.

h2. Create a Branch

p. Let's call our new branch 'greet'.

Execute:
git checkout -b greet
!git status

p(note). *NOTE:* @git checkout -b <branchname>@ is a shortcut for @git
branch <branchname>@ followed by a @git checkout <branchname>@.

p. Notice that the git status command reports that you are on the
'greet' branch.

h2. Changes for Greet: Add a Greeter class.

File: lib/greeter.rb
class Greeter
  def initialize(who)
    @who = who
  end
  def greet
    "Hello, #{@who}"
  end
end
EOF

Execute:
git add lib/greeter.rb
git commit -m "Added greeter class"

h2. Changes for Greet: Modify the main program

p. Update the hello.rb file to use greeter

File: lib/hello.rb
require 'greeter'

# Default is World
name = ARGV.first || "World"

greeter = Greeter.new(name)
puts greeter.greet
EOF

Execute:
git add lib/hello.rb
git commit -m "Hello uses Greeter"

h2. Changes for Greet: Update the Rakefile

p. Update the Rakefile to use an external ruby process

File: Rakefile
#!/usr/bin/ruby -wKU

task :default => :run

task :run do
  ruby '-Ilib', 'lib/hello.rb'
end
EOF

Execute:
git add Rakefile
git commit -m "Updated Rakefile"

h2. Up Next

p. We now have a new branch called *greet* with 3 new commits on it.
Next we will learn how to navigate and switch between branches.

----------------------------------------------------------------------
h1. Navigating Branches

h3. Goals

* Learn how to navigate between the branches of a repository

p. You now have two branches in your project:

Execute:
git hist --all
=log

Output:
=log
EOF

h2. Switch to the Master Branch

p. Just use the @git checkout@ command to switch between branches.

Execute:
git checkout master
=checkout
cat lib/hello.rb
=cat

Output:
=checkout
=cat
EOF

p. You are now on the master branch.  You can tell because the
hello.rb file doesn't use the @Greeter@ class.

h2. Switch Back to the Greet Branch.

Execute:
git checkout greet
=checkout2
cat lib/hello.rb
=cat2

Output:
=checkout2
=cat2
EOF

p. The contents of the @lib/hello.rb@ confirms we are back on the
*greet* branch.

----------------------------------------------------------------------
h1. Changes in Master

h3. Goals

* Learning how to deal with multiple branches with different (and possibly conflicting) changes.

p. While you were changing the greet branch, someone else decided to
update the master branch.  They added a README.

h2. Switch to the master branch.

Execute:
git checkout master

h2. Create the README.

File: README
This is the Hello World example from the git tutorial.
EOF

h2. Commit the README to master.

Execute:
git add README
git commit -m "Added README"

----------------------------------------------------------------------
h1. Viewing Diverging Branches

h3. Goals

* Learn how to view diverging branches in a repository.

h2. View the Current Branches

p. We now have two diverging branches in the repository.  Use the
following log command to view the branches and how they diverge.

Execute:
git hist --all
=log

Output:
=log
EOF

p. Here is our first chance to see the @--graph@ option on @git hist@ in
action. Adding the @--graph@ option to @git log@ causes it to draw the
commit tree using simple ASCII characters.  We can see both branches
(greet and master), and that the master branch is the current HEAD.
The common ancestor to both branches is the "Added a Rakefile" branch.

p. The @--all@ flag makes sure that we see all the branches.  The
default is to show only the current branch.

----------------------------------------------------------------------
h1. Merging

h3. Goals

* Learn how to merge two diverging branches to bring the changes back into a single branch.

h2. Merge the branches

p. Merging brings the changes in two branches together.  Let's go back
to the greet branch and merge master onto greet.

Execute:
git checkout greet
=checkout
git merge master
=merge
git hist --all
=hist

Output:
=checkout
=merge
=hist
EOF

p. By merging master into your greet branch periodically, you can pick
up any changes to master and keep your changes in greet compatible
with changes in the mainline.

p. However, it does produce ugly commit graphs. Latter we will look at
the option of rebasing rather than merging.

h2. Up Next

p. But first, what if the changes in master conflict with the changes
in greet?

----------------------------------------------------------------------
h1. Creating a Conflict

h3. Goals

* Create a conflicting change in the master branch.

h2. Switch back to master and create a conflict

p. Switch back to the master branch and make this change:

Execute:
git checkout master

File: lib/hello.rb
puts "What's your name"
my_name = gets.strip

puts "Hello, #{my_name}!"
EOF

Execute:
git add lib/hello.rb
git commit -m "Made interactive"

h2. View the Branches

Execute:
git hist --all
=log

Output:
=log
EOF

p. Master at commit "Added README" has been merged to the greet
branch, but there is now an additional commit on master that has not
been merged back to greet.

h2. Up Next

p. The latest change in master conflicts with some existing changes in
greet.  Next we will resolve those changes.

----------------------------------------------------------------------
h1. Resolving Conflicts

h3. Goals

* Learn how to handle conflicts during a merge

h2. Merge master to greet

p. Now go back to the greet branch and try to merge the new master.

Execute:
git checkout greet
!git merge master

Output:
$ git checkout greet
Switched to branch 'greet'
$ git merge master
Auto-merging lib/hello.rb
CONFLICT (content): Merge conflict in lib/hello.rb
Automatic merge failed; fix conflicts and then commit the result.
EOF

If you open lib/hello.rb, you will see:

file: lib/hello.rb
<<<<<<< HEAD
require 'greeter'

# Default is World
name = ARGV.first || "World"

greeter = Greeter.new(name)
puts greeter.greet
=======
# Default is World

puts "What's your name"
my_name = gets.strip

puts "Hello, #{my_name}!"
>>>>>>> master
EOF

p. The first section is the version on the head of the current branch
(greet).  The second section is the version on the master branch.

h2. Fix the Conflict

p. You need to manually resolve the conflict.  Modify @lib/hello.rb@
to be the following.

File: lib/hello.rb
require 'greeter'

puts "What's your name"
my_name = gets.strip

greeter = Greeter.new(my_name)
puts greeter.greet
EOF

h2. Commit the Conflict Resolution

Execute:
git add lib/hello.rb
=add
git commit -m "Merged master fixed conflict."
=commit

Output:
=add
=commit
EOF

h2. Advanced Merging

p. git doesn't provide any graphical merge tools, but it will gladly
work with any third party merge tool you wish to use.  See
"http://onestepback.org/index.cgi/Tech/Git/UsingP4MergeWithGit.red":http://onestepback.org/index.cgi/Tech/Git/UsingP4MergeWithGit.red
for a description of using the Perforce merge tool with git.

----------------------------------------------------------------------
h1. Rebasing VS Merging

h3. Goals

* Learn the differences between rebasing and merging.

h3. Discussion

p. Let's explore the differences between merging and rebasing.  In
order to do so, we need to rewind the repository back in time before
the first merge, and then redo the same steps, but using rebasing
rather than merging.

p. We will make use the of the @reset@ command to wind the branches
back in time.

----------------------------------------------------------------------
h1. Resetting the Greet Branch

h3. Goals

* Reset the greet branch to the point before the first merge.

h2. Reset the greet branch

p. Let's go back in time on the greet branch to the point _before_ we
merged master onto it.  We can *reset* a branch to any commit we want.
Essentially this is modifying the branch pointer to point to anywhere
in the commit tree.

p. In this case we want to back greet up to the point prior to the
merge with master.  We need to find the last commit before the merge.

Execute:
git checkout greet
=checkout
git hist
=log

Output:
=checkout
=log
EOF

p. That's a bit hard to read, but looking at the data we see that the
"Updated Rakefile" commit was the last commit on the greet branch
before merging.  Let's reset the greet branch to that commit.

Set: hash=hash_for("Updated Rakefile")
Execute:
git reset --hard <hash>
=reset

Output:
=reset
EOF

h2. Check the branch.

p. Look at the log for the greet branch.  We no longer have the merge
commits in its history.

Execute:
git hist --all
=log2

Output:
=log2
EOF

----------------------------------------------------------------------
h1. Resetting the Master Branch

h3. Goals

* Reset the master branch to the point before the conflicting commit.

h2. Reset the master branch

p. When we added the interactive mode to the master branch, we made a
change that conflicted with changes in the greet branch. Let's rewind
the master branch to a point before the conflicting change.  This
allows us to demonstrate the rebase command without worrying about
conflicts.

Execute:
git checkout master
git hist
=log

Output:
=log
EOF

p. The 'Added README' commit is the one directly before the
conflicting interactive mode.  We will reset the master branch to
'Added README' branch.

Set: hash=hash_for("Added README")
Execute:
git reset --hard <hash>
git hist --all
=log2

p. Review the log.  It should look like the repository has been wound
back in time to the point before we merged anything.

Output:
=log2
EOF

----------------------------------------------------------------------
h1. Rebasing

h3. Goals

* Use the rebase command rather than the merge command.

p. Ok, we are back in time before the first merge and we want to get
the changes in master into our greet branch.

p. This time we will use the rebase command instead of the merge
command to bring in the changes from the master branch.

Execute:
git checkout greet
git rebase master
git hist
=log

Output:
$ go greet
Switched to branch 'greet'
$
$ git rebase master
First, rewinding head to replay your work on top of it...
Applying: added Greeter class
Applying: hello uses Greeter
Applying: updated Rakefile
$
=log
EOF

h2. Merge VS Rebase

p. The final result of the rebase is very similar to the merge.  The
greet branch now contains all of its changes, as well as all the
changes from the master branch.  However, the commit tree is quite
different.  The commit tree for the greet branch has been rewritten so
that the master branch is a part of the commit history.  This leaves
the chain of commits linear and much easier to read.

h2. When to Rebase, When to Merge?

p. Don't use rebase ...

# If the branch is public and shared with others.  Rewriting publicly shared branches will tend to screw up other members of the team.
# When the _exact_ history of the commit branch is important (since rebase rewrites the commit history).

p. Given the above guidelines, I tend to use rebase for short-lived,
local branches and merge for branches in the public repository.

----------------------------------------------------------------------
h1. Merging Back to Master

h3. Goals

* We've kept our greet branch up to date with master (via rebase), now let's merge the greet changes back into the master branch.

h2. Merge greet into master

Execute:
git checkout master
git merge greet
=merge

Output:
$ git checkout master
Switched to branch 'master'
$
=merge
EOF

p. Because the head of master is a direct ancestor of the head of the
greet branch, git is able to do a fast-forward merge.  When
fast-forwarding, the branch pointer is simply moved forward to point
to the same commit as the greeter branch.

p. There will never be conflicts in a fast-forward merge.

h2. Review the logs

Execute:
git hist
=log

Output:
=log
EOF

p. The greet and master branches are now identical.

----------------------------------------------------------------------
h1. Multiple Repositories

p. Up to this point we have been working with a single git repository.
However, git excels at working with multiple repositories.  These
extra repositories may be stored locally, or may be accessed across a
network connection.

p. In the next section we will create a new repository called
"cloned_hello".  We will show how to move changes from one repository
to another, and how to handle conflicts when they arise from between
two repositories.

 !git_clone.png!


p. For now, we will be working with local repositories
(i.e. repositories stored on your local hard disk), however most of
the things learned in this section will apply to multiple repositories
whether they are stored locally or remotely over a network.

p. *NOTE:* We are going be making changes to both copies of our
repositories.  Make sure you pay attention to which repository you are
in at each step of the following labs.

----------------------------------------------------------------------
h1. Cloning Repositories

h3. Goals

* Learn how to make copies of repositories.

h2. Go to the work directory

p. Go to the working directory and make a clone of your hello
repository.

Execute:
cd ..
=cd
pwd
=pwd
ls
=ls

p{color:red}. *NOTE: Now in the work directory.*

Output:
=cd
=pwd
=ls
EOF

p. At this point you should be in your "work" directory.  There should
be a single repository here named "hello".

h2. Create a clone of the hello repository

p. Let's make a clone of the repository.

Execute:
git clone hello cloned_hello
=clone
ls
=ls2
+cd cloned_hello
+git config user.name "Jim Weirich"
+git config user.email "jim (at) edgecase.com"
+cd ..

Output:
=clone
=ls2
EOF

p. There should now be two repositories in your work directory: the
original "hello" repository and the newly cloned "cloned_hello"
repository.

----------------------------------------------------------------------
h1. Review the Cloned Repository

h3. Goals

* Learn about branches on remote repositories.

h2. Look at the cloned repository

p. Let's take a look at the cloned repository.

Execute:
cd cloned_hello
=cd
ls
=ls

Output:
=cd
=ls
EOF

p. You should see a list of all the files in the top level of the
original repository (@README@, @Rakefile@ and @lib@).


h2. Review the Repository History

Execute:
git hist --all
=log

Output:
=log
EOF

p. You should now see a list of the all the commits in the new
repository, and it should (more or less) match the history of commits
in the original repository.  The only difference should be in the
names of the branches.

h2. Remote branches

p. You should see a *master* branch (along with *HEAD*) in the history
list.  But you will also have number of strangely named branches
(*origin/master*, *origin/greet* and *origin/HEAD*).  We'll talk about
them in a bit.

----------------------------------------------------------------------
h1. What is Origin?

h3. Goals

* Learn about naming remote repositories.

Execute:
git remote
=remote

Output:
=remote
EOF

p. We see that the cloned repository knows about a remote repository
named origin.  Let's see if we can get more information about origin:

Execute:
git remote show origin
=show

Output:
=show
EOF

p. Now we see that the remote repository "origin" is simply the original
*hello* repository.  Remote repositories typically live on a separate
machine, possibly a centralized server.  As we can see here, however,
they can just as well point to a repository on the same machine.
There is nothing particularly special about the name "origin",
however the convention is to use the name "origin" for
the primary centralized repository (if there is one).

----------------------------------------------------------------------
h1. Remote Branches

h3. Goals

* Learn about local VS remote branches

p. Let's look at the branches available in our cloned repository.

Execute:
git branch
=branch

Output:
=branch
EOF

p. That's it, only the master branch is listed.  Where is the greet
branch?  The *git* *branch* command only lists the local branches by
default.

h2. List Remote Branches

p. Try this to see all the branches:

Execute:
git branch -a
=branch_a

Output:
=branch_a
EOF

p. Git has all the commits from the original repository, but branches
in the remote repository are not treated as local branches here.  If
we want our own *greet* branch, we need to create it ourselves. We
will see how to do that in a minute.

----------------------------------------------------------------------
h1. Change the Original Repository

h3. Goals

* Make some changes to the original repository so we can try to pull the changes

h2. Make a change in the original *hello* repository

Execute:
cd ../hello
+pwd
# (You should be in the original hello repository now)

p{color:red}. *NOTE: Now in the _hello_ repo*

p. Make the following changes to README:

File: README
This is the Hello World example from the git tutorial.
(changed in original)
EOF

p. Now add and commit this change

Execute:
git add README
git commit -m "Changed README in original repo"

h2. Up Next

p. The original repository now has later changes that are not in the
cloned version.  Next we will pull those changes across to the cloned
repository.

----------------------------------------------------------------------
h1. Fetching Changes

h3. Goals

* Learn how to pull changes from a remote repository.

Execute:
cd ../cloned_hello
+pwd
git fetch
=fetch
git hist --all
=hist

p{color:red}. *NOTE: Now in the _cloned_hello_ repo*

Output:
=fetch
=hist
EOF

p. At this point the repository has all the commits from the original
repository, but they are not integrated into the the cloned
repository's local branches.

p. Find the "Changed README in original repo" commit in the history
above.  Notice that the commit includes "origin/master" and
"origin/HEAD".

p. Now look at the "Updated Rakefile" commit.  You will see that it
the local master branch points to this commit, not to the new commit
that we just fetched.

p. The upshot of this is that the "git fetch" command will fetch new
commits from the remote repository, but it will not merge these
commits into the local branches.

h2. Check the README

We can demonstrate that the cloned README is unchanged.

Execute:
cat README

Output:
$ cat README
This is the Hello World example from the git tutorial.
EOF

p. See, no changes.

----------------------------------------------------------------------
h1. Merging Pulled Changes

h3. Goals

* Learn to get the pulled changes into the current branch and working directory.

h2. Merge the fetched changes into local master

Execute:
git merge origin/master
=merge

Output:
=merge
EOF

h2. Check the README again

p. We should see the changes now.

Execute:
cat README

Output:
$ cat README
This is the Hello World example from the git tutorial.
(changed in original)
EOF

p. There are the changes.  Even though "git fetch" does not merge the
changes, we can still manually merge the changes from the remote
repository.

h2. Up Next

p. Next let's take a look at combining the fetch & merge process into
a single command.

----------------------------------------------------------------------
h1. Pulling Changes

h3. Goals

* Learn that @git pull@ is equivalent to a @git fetch@ followed by a @git merge@.

h3. Discussion

p. We're not going to go through the process of creating another
change and pulling it again, but we do want you to know that doing:

pre(instructions). git pull

is indeed equivalent to the two steps:

pre(instructions). git fetch
git merge origin/master

----------------------------------------------------------------------
h1. Adding a Tracking Branch

h3. Goals

* Learn how to add a local branch that tracks a remote branch.

p. The branches starting with remotes/origin are branches from the
original repo.  Notice that you don't have a branch called greet
anymore, but it knows that the original repo had a greet branch.

h2. Add a local branch that tracks a remote branch.

Execute:
git branch --track greet origin/greet
=branch_track
git branch -a
=branch_a
git hist --max-count=2
=log

Output:
=branch_track
=branch_a
=log
EOF

p. We can now see the greet branch in the branch list and in the log.

----------------------------------------------------------------------
h1. Bare Repositories

h3. Goals

* Learn how to create bare repositories.

p. Bare repositories (without working directories) are usually used for
sharing).

h2. Create a bare repository.

Execute:
cd ..
+pwd
git clone --bare hello hello.git
=clone
ls hello.git
=ls

p{color:red}. *NOTE: Now in the work directory*

Output:
=clone
=ls
EOF

p. The convention is that repositories ending in '.git' are bare
repositories.  We can see that there is no working directory in the
hello.git repo.  Essentially it is nothing but the .git directory of a
non-bare repo.

----------------------------------------------------------------------
h1. Adding a Remote Repository

h3. Goals

* Add the bare repository as a remote to our original repository.

p. Let's add the hello.git repo to our original repo.

Execute:
cd hello
+pwd
git remote add shared ../hello.git

p{color:red}. *NOTE: Now in the +hello+ repository.*

----------------------------------------------------------------------
h1. Pushing a Change

h3. Goals

* Learn how out to push a change to a remote repository.

p. Since bare repositories are usually shared on some sort of network
server, it is usually difficult to cd into the repo and pull changes.
So we need to push our changes into other repositories.

p. Let's start by creating a change to be pushed.  Edit the README and
commit it

File: README
This is the Hello World example from the git tutorial.
(Changed in the original and pushed to shared)
EOF

Execute:
git checkout master
git add README
git commit -m "Added shared comment to readme"

p. Now push the change to the shared repo.

Execute:
git push shared master
=push

p. _shared_ is the name of the repository receiving the changes we are
pushing. (Remember, we added it as a remote in the previous lab.)

Output:
=push
EOF

p(note). *NOTE:* We had to explicitly name the branch master that was
receiving the push.  It is possible to set it up automatically, but I
_never_ remember the commands to do that.  Check out the "Git Remote
Branch" gem for easy management of remote branches.

----------------------------------------------------------------------
h1. Pulling Shared Changes

h3. Goals

* Learn how to pull changes from a shared repository.

p. Quick hop over to the clone repository and let's pull down the
changes just pushed to the shared repo.

Execute:
cd ../cloned_hello
+pwd

p{color:red}. *NOTE: Now in the _cloned_hello_ repo.*

p. Continue with...

Execute:
git remote add shared ../hello.git
git branch --track shared master
git pull shared master
cat README

----------------------------------------------------------------------
h1. Hosting your Git Repositories

h3. Goals

* Learn how to setup git server for sharing repositories.

p. There are many ways to share git repositories over the network.
Here is a quick and dirty way.

h2. Start up the git server

execute:
# (From the work directory)
git daemon --verbose --export-all --base-path=.

p. Now, in a separate terminal window, go to your work directory

execute:
# (From the work directory)
git clone git://localhost/hello.git network_hello
cd network_hello
ls

p. You should see a copy of hello project.

h2. Pushing to the Git Daemon

p. If you want to push to the git daemon repository, add
@--enable=receive-pack@ to the git daemon command.  Be careful because
there is no authentication on this server, anyone could push to your
repository.

----------------------------------------------------------------------
h1. Sharing Repos

h3. Goals

* Learn to share repos across WIFI.

p. See if your neighbor is running the git daemon.  Exchange IP
addresses and see if you can pull from each other's repositories.

p(note). *NOTE:* The gitjour gem is really useful in sharing
ad-hoc repositories.

----------------------------------------------------------------------
h1. Advanced / Future Topics

p. Here are some topics you might want to research on your own:

* Reverting Committed Changes
* Cross OS Line Endings
* Remote Servers
* Protocols
* SSH Setup
* Remote Branch Management
* Finding Buggy Commits (git bisect)
* Workflows
* Non-command line tools (gitx, gitk, magit)
* Working with GitHub

----------------------------------------------------------------------
h1. Thank You

p. Thank you for trying out the Git Immersion Labs.  Feel free to send
comments to jim.weirich@gmail.com.

