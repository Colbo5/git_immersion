----------------------------------------------------------------------
h1. Configuration

h3. Buts

* Configurer git pour qu'il soit prêt à être utilisé.

h2. Configurer son nom et son email

p. Si vous n'avez jamais utilisé git avant, vous allez devoir faire quelques
paramétrages d'abord.
Lancer les commandes suivantes pour que git connaisse votre nom et votre email.
Si vous avez déjà configuré git, vous pouvez passez plus bas à la partie sur
les fins de ligne.

execute:
git config --global user.name "Your Name"
git config --global user.email "your_email@whatever.com"

h2. Paramétrer les préférences du type de fin de lignes

Aussi, pour les utilisateurs Unix/Mac:

execute:
git config --global core.autocrlf input
git config --global core.safecrlf true

Et pour les utilisateurs Windows:

execute:
git config --global core.autocrlf true
git config --global core.safecrlf true

----------------------------------------------------------------------
h1. Configuration supplémentaire

h3. Buts

* Avoir le matériel pour le tutoriel paramétré et prêt à être utilisé.

h2. Obtenir le paquet pour le tutoriel.

p. Télécharger le paquet pour le tutoriel depuis:

* L'URL "http://gitimmersion.com/git_tutorial.zip":http://gitimmersion.com/git_tutorial.zip

h2. Dézipper le tutoriel

p. Le paquet pour le tutoriel doit contenir un répertoire principal "git_tutorial"
avec trois sous-répertoires:

* html -- Ces fichiers html.  Lancer votre navigateur depuis html/index.html
* work -- Un répertoire de travail vide.  Créer votre dépôt dedans.
* repos -- Dépôts Git préparés pour vous permettre d'avancer dans le tutoriel
en partant de n'importe quelle étape.  Si vous êtes bloqué, copier juste le
dépôt souhaité dans votre répertoire de travail.

----------------------------------------------------------------------
h1. Créer un projet

h3. Buts

* Apprendre à créer un dépôt git à partir de rien.

h2. Créer un programme "Hello, World"

p. En commençant dans le répertoire de travail vide, créer un répertoire vide
nommé "hello", ensuite créer un fichier nommé @hello.rb@ avec le contenu
ci-dessous.

Execute:
mkdir hello
cd hello

File: hello.rb
puts "Hello, World"
EOF

h2. Créer le dépôt

p. Vous avez maintenant un répertoire avec un fichier unique. Pour créer une
dépôt git depuis ce répertoire, lancer la commande git init.

Execute:
git init
=init
+git config user.name "Jim Weirich"
+git config user.email "jim (at) edgecase.com"

Output:
=init
EOF

h2. Ajouter le programme au dépôt

Maintenant ajoutons le fichier du programme "Hello, World" au dépôt.

Execute:
git add hello.rb
=add
git commit -m "First Commit"
=commit

p. Vous devriez voir ...

Output:
=add
=commit
EOF

----------------------------------------------------------------------
h1. Vérifier le status

h3. Buts

* Apprendre comment vérifier le statut du dépôt

h2. Vérifier le status du dépôt

p. Utiliser la commande @git status@ pour vérifier le statut de votre dépôt.


Execute:
git status
=status

p. Vous devriez voir

Output:
=status
EOF

p. La commande status renvoie qu'il n'y a rien à commiter. Cela
signifie que le dépôt a l'état complet du répertoire de travail.
Il n'y a pas de changements signalés comme à enregistrer.

p. Nous allons utiliser la commande @git status@ pour continuer à suivre
l'état entre le dépôt et le répertoire de travail.

----------------------------------------------------------------------
h1. Effectuer des changements

h3. Buts

* Apprendre comment suivre l'état du répertoire de travail

h2. Changer le programme "Hello, World".

p. Il est temps de changer notre programme hello pour lui passer un argument
depuis la ligne de commande. Changer le fichier pour qu'il soit:

File: hello.rb
puts "Hello, #{ARGV.first}!"
EOF

h2. Vérifier le status

p. Maintenant vérifier le statut de du répertoire de travail.

Execute:
!git status
=status

p. Vous devriez voir ...

Output:
=status
EOF

p. La première chose à constater est que git sait que le fichier @hello.rb@
a été modifié, mais que git n'a pas encore averti de ces changements.

p. Noter également que le message de status vous guide sur ce que vous alles
devoir faire par la suite. Si vous voulez ajouter ces changements au répertoire,
alors utiliser la commande @git add@. Dans le cas contraire, la commande
@git checkout@ peut être utilisé pour annuler les changements.

h2. Up Next

p. Let's stage the change.

----------------------------------------------------------------------
h1. Déclarer les changements

h3. Buts

* Apprendre à déclarer les changements pour les commits à venir

h2. Ajouter les changements

p. Maintenant indiquer à git de prendre en compte les changements déclarés. Vérifier le status

Execute:
git add hello.rb
=add
git status
=status

p. Vous devriez voir ...

Output:
=add
=status
EOF

p. Le changement sur le fichier @hello.rb@ a été déclaré. Cela signifie
que git est informé du changement, mais le changement n'a pas pas encore
eté enregistré de manière _permanente_ dans le dépôt. La prochaine opération
de commit inclura les changements qui ont été déclarés.

p. Si vous décidez que vous _ne_ voulez pas commiter ce changement après tout,
la commande de status vous rappelle que la commande @git reset@ peut être
utilisée pour annuler cet déclaration de ce changement.

----------------------------------------------------------------------
h1. Déclarer et commiter

p. Une étape de déclaration des fichiers séparée depuis git est en rapport
avec la philosophie de ne pas être bloqué tant que vous n'avez pas besoin
d'utiliser un gestionnaire de version.
Vous pouvez continuer à faire des changements dans votre répertoire de travail
et ensuite, lorsque vous devez commencer à utiliser le gestion de version, git
vous permet d'enregistrer vos changements dans de petits commits qui
enregistrent exacteemnt ce que vous avez fait.

p. Par exemple, supposons que vous éditiez trois fichiers (@a.rb@, @b.rb@, et
@c.rb@). Maintenant vous voulez commiter tous les changements, mais vous voulez
que les changements dans @a.rb@ et @b.rb@ soit dans un seul commit et que ceux
dans @c.rb@uuu sans rapport logique avec les deux premiers fichiers soit dans
 une commit séparé.

p. Vous pourriez faire:

pre(instructions).
git add a.rb
git add b.rb
git commit -m "Changes for a and b"

pre(instructions).
git add c.rb
git commit -m "Unrelated change to c"

p. En séparant la déclaration du commit, vous avez la possibilité de
choisir précisément et facilement ce que vous ajoutez à chaque commit.

----------------------------------------------------------------------
h1. Commiter les changements

h3. Buts

* Apprendre à commiter les changements au dépôt

h2. Commiter le changement

p. Ok, assez avec la déclaration.  Maintenant commitons ce que nous avons
déclaré dans le répertoire.

p. Quand vous avez utilisé @git commit@ précédemment pour commiter la version
initiale du fichier @hello.rb@ dans le dépôt, vous avez inclus l'indicateur @-m@
qui renvoie un commentaire dans la ligend de commande. La commande de commit va
vous permettre d'éditer un commentaire de manière interactive pour le commit.
Essayons maintenant.

p. Si vous oubliez l'indicateur @-m@ depuis la ligne de commande, git va vous
ouvrir l'éditeur de texte de votre choix. Cet éditeur est choisi en s'appuyant
sur la liste suivante (avec par ordre de priorité):

* la variable d'environnement GIT_EDITOR
* le paramètre de configuration core.editor
* la variable d'environnement VISUAL
* la variable d'environnement EDITOR

p. J'ai la variable EDITOR définie à @emacsclient@.

p. Ainsi commitons maintenant et vérifions le status.

Execute:
-git commit
+git commit -m "Using ARGV"

p. You should see the following in your editor:

Output:
|
# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#	modified:   hello.rb
#
EOF

p. Sur la première ligne, entrer le commentaire: "Using ARGV".  Sauver le
fichier et sortir de l'éditeur. Vous devriez voir ...

Output:
git commit
Waiting for Emacs...
[master 569aa96] Using ARGV
 1 files changed, 1 insertions(+), 1 deletions(-)
EOF

p. La ligne "Waiting for Emacs..." vient du programme @emacsclient@ qui envoie
le fichier au programme dmacs et attend que le fichier soit fermé. Le reste de
la sortie est constitué des messages standards pour un commmit
messages.

h2. Vérifier le status

p. Finalement essayons de vérifier le status encore.

Execute:
!git status
=status

Vous devriez voir ...

Output:
=status
EOF

p. Le répertoire de travail est propre et prêt pour que vous continuiez.

----------------------------------------------------------------------
h1. Changements, pas fichiers

h3. Buts

* Apprendre que git fonctionne avec les changements, pas avec les fichiers.

p. La plupart des logiciels de gestion de version travaillent avec des
fichiers. Vous ajoutez un fichier à la source versionnée et le sytème suivra
les changements que vous effectuez dessus à partir de ce moment.

p. Git se concentre sur les changements dans un fichier plutôt que sur le
fichier en lui même.
Quand vous faites @git add file@, vous ne dites pas à git d'ajouter le fichier
au dépôt. Vous dites plutôt que git devrait prendre en compte la situation de
ce fichier pour qu'il soit commité plus tard.

p. Nous allons chercher à vous faire explorer cette différence dans cette
partie.

h2. Premier changement: autoriser un nom de fichier par défaut

p. Changer le programme "Hello, World" pour avoir une valeur par défault si un
argument est passé en ligne en commande si il n'est pas supplié.

File: hello.rb
name = ARGV.first || "World"

puts "Hello, #{name}!"
EOF

h2. Rajouter ce changement

p. Maintenant ajouter ce changement dans la déclaration des fichiers de git.

Execute:
git add hello.rb

h2. Deuxième changement: ajouter une commentaire

p. Maintenant ajouter un commentaire au programme "Hello, World".

File: hello.rb
# Default is "World"
name = ARGV.first || "World"

puts "Hello, #{name}!"
EOF

h2. Vérifier le status courant

Execute:
!git status
=status

p. Vous devriez voir ...

Output:
=status
EOF

p. Remarquer comment @hello.rb@ est listé deux fois dans le status. Le premier
changement (ajouter une valeur par défaut) est déclarée et est prête à être commité.
Le second changement (ajouter un commentaire) n'est pas déclaré. Si vous deviez
commiter dès maintenant, le commentaire ne serait pas sauvé dans le dépôt.

p. Maintenant essayons cela.

h2. Commiter

p. Commiter le changement déclaré (la valeur par défaut), et ensuite revérifions le status.

Execute:
git commit -m "Added a default value"
=commit
git status
=status2

p. Vous devriez voir ...

Output:
=commit
=status2
EOF

p. La commande de status vous dis que @hello.rb@ a des changements non enregistrés,
mais n'est plus dans la liste des fichiers déclarés.

h2. Ajouter le second changement

p. Maintenant ajouter le second changement à la liste des fichiers déclarés,
ensuite lancer git status.

Execute:
git add .
!git status
=status3

p(note). *Note:* Nous utilisons le répertoire courrant ('.') comme le
fichier à ajouter. C'est vraiment un raccourci pratique pour ajouter tous
les changements au fichiers dans le répertoire courant et en dessous. Mais
comme il ajoute tout, c'est _vraiment_ une bonne idée de vérifier le status
avant de faire un <tt>add .</tt>, juste pour s'assurer que vous n'ajoutez aucun
fichier qui ne soit pas désiré.

p(note). Je voulais que voyiez l'astuce "add .", mais nous allons continuer
à ajouter explicitement les fichiers dans le reste du tutoriel juste pour
être sûr.

p. Vous devriez voir ...

Output:
=status3
EOF

p. Maintenant le second changement a été déclaré et est prêt à être commité.

h2. Commiter le second changement

Execute:
git commit -m "Added a comment"

----------------------------------------------------------------------
h1. Historique

h3. Buts

* Apprendre comment voir l'historique du projet.

p. Avoir une liste des changements qui ont été effectués est le rôle de la
commande @git log@.

Execute:
git log
=log

p. Vous devriez voir ...

Output:
=log
EOF

p. Voici la liste des quatre commits que nous avons fait dans le dépôt
jusqu'à maintenant.

h2. Historique avec entrées sur une ligne

p. Vous avez une grande possibilité de contrôle sur ce que la commande @log@
renvoie. J'aime bien le formatage sur une ligne:

Execute:
git log --pretty=oneline
=oneline

p. Vous devriez voir ...

Output:
=oneline
EOF

h2. Contrôler quelles entrées sont affichées

p. Il y a beaucoup d'options pour sélectionner quelles entrées sont
affichées dans le log. Jouez avec les commandes suivantes:

pre(instructions).
git log --pretty=oneline --max-count=2
git log --pretty=oneline --since='5 minutes ago'
git log --pretty=oneline --until='5 minutes ago'
git log --pretty=oneline --author=<your name>
git log --pretty=oneline --all

p. Voir man git-log pour tous les détails.

h2. Devenir imaginatif

p. Voici ce que j'utilise pour vérifier les changements fait dans la dernière semaine.
J'ajouterai @--author=jim@ si je veux seulement les changements que j'ai fait.

pre(instructions).
git log --all --pretty=format:"%h %cd %s (%an)" --since='7 days ago'

h2. Le formatage de fichier de log ultime

p. Au fil du temps, j'ai décidé que j'aimais le formatage de log suivant
pour la plupart de mon travail.

Execute:
git log --pretty=format:"%h %ad | %s%d [%an]" --graph --date=short
=ultimate

Cela ressemble à:

Output:
=ultimate
EOF

p. Regardons cette ligne dans le détail:

* @--pretty="..."@ définit le format de sortie.
* @%h@ est la hash abrégé du commit
* @%d@ sont le type de décoration sur ce commit (comme les branches ou les tags)
* @%ad@ est la date de l'auteur
* @%s@ est le commentaire
* @%an@ est le nom de l'auteur
* @--graph@ informe git d'afficher l'arbre de commit dans un rendu de type graphe ASCII
* @--date=short@ garde le format de la date joli et court

p. C'est beaucoup à taper chaque fois que vous voulez voir le log.
Heuseusement nous apprendrons à utiliser les alias git dans la prochaine partie.

h2. Autres outils

p. Les deux <code>gitx</code> (pour Macs) et <code>gitk</code> (chaque plateforme)
sont utile pour exlorer l'historique des logs.

----------------------------------------------------------------------
h1. Alias

h3. Buts

* Apprendre comment paramétrer les alias et les raccourcis pour les commandes git

h2. Alias communs

p. +git status+, +git add+, +git commit+, et +git checkout+ sont ces
commandes habituelles dont il est utile d'avoir des abbréviations.

p. Ajouter ce qui suit dans le fichier .gitconfig dans votre répertoire $HOME.

file: .gitconfig
[alias]
  co = checkout
  ci = commit
  st = status
  br = branch
  hist = log --pretty=format:\"%h %ad | %s%d [%an]\" --graph --date=short
  type = cat-file -t
  dump = cat-file -p
EOF

p. Nous avons couverts checkout, commit et status. Et nous avons aussi
couvert la commande @log@ dans la précédente partie. Maintenant vous
pouvez taper @git co@ à la place de taper @git checkout@. De la même manière
@git st@ pour @git status@ et @git ci@ pour @git commit@. Et le meilleur de
tous, @git hist@ vous permettra d'éviter la très longue commande @log@.

p. Continuez et faites quelques essais pour essayer.

h2. Définir l'alias @hist@ dans votre fichier @.gitconfig@

p. Pour la plupart des cas, je continuerais à taper les commandes complètes
dans les instructions. La seule exception est que j'utiliserais l'alias @hist@
défini ci-dessus chaque fois que vous avez besoin de voir la sortie de log git.
Assurer vous d'avoir un alias @hist@ configuré dans votre fichier @.gitconfig@
avant de continuer le tutoriel suivant.

h2. @Type@ et @Dump@

p. Nous avons déjà ajouté quelques alias pour des commandes que nous n'avons
pas encore abordé. La commande @git branch@ va bientôt être abordée. et la
commande @git cat-file@ est utile pour explorer git, ce que nous verrons dans
un petit moment.

h2. Alias de la ligne de commande (optionnel)

p(note). *Note:* Cette section est pour les utilisateurs qui utilisent une ligne
de commande de type posix. Les utilisateurs Windows et utilisateurs n'utilisant pas
une ligne de commande non-posix peuvent passer à la prochaine partie.

p. Si votre ligne de commande supporte les alias et les raccourcis, ensuite vous
pouvez utiliser des alias à ce niveau également. Voici ceux que j'utilise:

file: .profile
alias gs='git status '
alias ga='git add '
alias gb='git branch '
alias gc='git commit'
alias gd='git diff'
alias go='git checkout '
alias gk='gitk --all&'
alias gx='gitx --all'

alias got='git '
alias get='git '
EOF

p. L'abbréviation @go@ pour @git checkout@ est particulièrement joli. Cela me
permet de taper:

pre(instructions). go <branch>

p. pour récupérer une branche particulière.

p. Et oui, je tape par erreur @git@ comme @get@ ou @got@ suffisamment souvent
pour créer l'alias pour eux.

----------------------------------------------------------------------
h1. Obtenir de vieille versions

h3. Buts

* Apprendre comment récupérer n'importe quelle état du dépôt dans le répertoire
de travail.

p. Retourner dans l'historique est très facile. La commande checkout va copier
n'importe quel état depuis le dépôt vers le répertoire de travail.

h2. Obtenir les hashs pour les précédentes versions

Execute:
git hist
=log

p(note). *Note:* Vous vous rappelez avoir défini @hist@ dans votre
fichier @.gitconfig@, n'est ce pas? Si ce n'est pas le cas, revoyez le tutoriel
sur les alias.

Output:
=log
EOF

p. Examiner la sortie du log et trouver le hash pour le premier commit. Cela
doit être la dernière ligne de la sortie de @git hist@. Utiliser le code hash
(les 7 premiers caractères sont suffisants) dans la commande ci-dessous. Ensuite,
vérifier le contenu du fichier hello.rb.

Set: hash=hash_for("First Commit")
Execute:
git checkout <hash>
=checkout
cat hello.rb
=cat

p(note). *Note:* Les commandes données ici sont des commandes Unix et
fonctionnent à la fois sous Mac et Linux. Malheureusement, les utilisateurs Windows
devront traduire pour leur ligne de commande propre (DOS).

p(note). *Note:* De nombreuses commandes dépendent des valeurs de hash
dans le dépôt. Comme vos valeurs de hash vont changer des miennes, chaque fois que
vous voyez quelque chose comme &lt;hash&gt; ou &lt;treehash&gt; dans la commande,
remplacer la valeur par votre propre valeur de dépôt.

p. Vous devriez voir ...

Output:
=checkout
=cat
EOF

p. La sortie de la commande @checkout@ explique la situation de manière assez
claire. Les vieilles versions de git vont se plaindre de ne pas être sur une
branche locale. Dans tous les cas, ne vous en inquiétez pas maintenant.

p. Noter que les contenus du fichier hello.rb sont les contenus originaux.

h2. Retourner la dernière version de la branche master

Execute:
git checkout master
=checkout2
cat hello.rb
=cat2

p. Vous devriez voir ...

Output:
=checkout2
=cat2
EOF

p. 'master' est le nom de la branche par défaut. En faisant un "checkout"
sur une branche, vous avez la dernière version de cette branche.

----------------------------------------------------------------------
h1. Tagger des versions

h3. Buts

* Apprendre comment tagger des commits avec des noms pour des références futures

p. Appelons la version courante du programme hello version 1 (v1).

h2. Tagger la version 1

Execute:
git tag v1
=tag

p. Maintenant vous pouvez vous référer à la version courante du programme comme v1.

h2. Tagger des versions précédentes

p. Taggons immédiatement la première version précédente à la version courante sous
le nom v1-beta.  D'abord, nous devons revenir à la version précédente. Plutôt que
d'utiliser le hash, nous allons utilise la notation @^@ pour indiquer "le parent
de v1".

p(note). Si la notation @v1@^ vous cause un problème, vous pouvez aussi essayer
@v1~1@, qui référencera la même version. Cette notation signifie le "premier
ancêtre de v1".

Execute:
git checkout v1^
=checkout
cat hello.rb
=cat

Output:
=checkout
=cat
EOF

p. Voir que c'est la version avec la valeur par défault _avant_ que nous ajoutions
le commentaire. Faisons cette v1-beta.

Execute:
git tag v1-beta

h2. Récupérer par nom de tag

p. Maintenant essayons de passer d'une version taggée à l'autre et inversement.

Execute:
git checkout v1
=cov1
git checkout v1-beta
=cov1beta

Output:
=cov1
=cov1beta
EOF

h2. Voir les tags en utilisant la commande @tag@

p. Vous pouvez voir quels tags sont disponibles en utilisant la commande @git tag@.

Execute:
git tag
=tag2

Output:
=tag2
EOF

h2. Voir les tags dans les logs

p. Vous pouvez aussi vérifier les tags dans le log.

Execute:
git hist master --all
=hist

Output:
=hist
EOF

p. Vous pouvez voir les deux tags (@v1@ et @v1-beta@) listés dans la sortie
de log, avec à côté le nom de la branche (@master@).  Aussi, @HEAD@ vous
montre le commit qui est actuellement utilisé (qui est le @v1-beta@ pour
le moment).

----------------------------------------------------------------------
h1. Annuler les changements locaux (avant les déclarations)

h3. Buts

* Apprendre comment revenir sur les changements dans votre répertoire de travail

h2. Repasser sur la branche master

p. S'assurer que vous êtes sur le dernier commit dans master avant de continuer.

Execute:
git checkout master

h2. Changer hello.rb

p. Quelquefois, vous avez modifié un fichier dans votre répertoire de travail local
et vous souhaitez simplement revenir à l'état de ce qui a été déjà commité. La
commande checkout va gérer cela.

Changer hello.rb pour avoir un mauvais commentaire.

File: hello.rb
# This is a bad comment.  We want to revert it.
name = ARGV.first || "World"

puts "Hello, #{name}!"
EOF

h2. Vérifier le status

p. En premier, vérifier le status du répertoire de travail.

Execute:
!git status
=status

Output:
=status
EOF

p. Nous voyons que le fichier @hello.rb@ a été modifié mais n'a pas encore été déclaré.

h2. Annuler les changements dans le répertoire de travail

p. Utiliser la commande @checkout@ pour récupérer la version du fichier @hello.rb@ issue
du dépôt.

Execute:
git checkout hello.rb
=checkout
!git status
=status2
cat hello.rb
=cat

Output:
=checkout
=status2
=cat
EOF

p. La commande status nous montre qu'il n'y a plus de changements indiqués
dans le répertoire de travail. Et le "mauvais commentaire" n'est plus dans
le contenu du fichier.

----------------------------------------------------------------------
h1. Annuler les déclarations de fichiers changés (avant de commiter)

h3. Buts

* Apprendre comment annuler des changements qui ont déjà été déclarés

h2. Changer le fichier et déclarer le changement

p. Modifier le fichier @hello.rb@ pour avoir un mauvais commentaire

File: hello.rb
# This is an unwanted but staged comment
name = ARGV.first || "World"

puts "Hello, #{name}!"
EOF

p. Et maintenant continuer et déclarer le fichier.

Execute:
git add hello.rb

h2. Vérifier le status

p. Vérifier le status de votre changement non désiré.

Execute:
git status
=status

Output:
=status
EOF

p. La sortie du status montre que le changement a été déclaré et qu'il
est prêt à être commité.

h2. Réinitialiser la liste des fichiers déclarés

p. Heureusement la ligne de status nous dit exactement comment faire pour
annuler la déclaration du changement.

Execute:
git reset HEAD hello.rb
=reset

Output:
=reset
EOF

p. La commande @reset@ réinitialise la liste des fichiers déclarés à celle
qui est dans HEAD. Cela nettoye la liste des fichiers déclarés du changement
que nous venions juste de déclarer.

p. La commande @reset@ (par défaut) ne change pas le répertoire de travail
courant. Ainsi le répertoire de travail a toujours le commentaire non souhaité.
Nous pouvons utiliser la commande @checkout@ de la précédente partie pour enlever
la changement non désiré du répertoire de travail.

h2. Mettre à jour à la version commitée

Execute:
git checkout hello.rb
git status
=status2

Output:
=status2
EOF

p. Et notre répertoire de travail est propre à nouveau.

----------------------------------------------------------------------
h1. Annuler les changements déjà commités

h3. Buts

* Apprendre comment annuler revenir sur les changements qui ont déjà
été commités sur le dépôt local.

h2. Annuler des commits

p. Parfois vous réalisez qu'un changement que vous avez déjà commité
n'était pas correct et vous souhaitez annuler ce commit. Il y a
plusieurs façons de gérer ce problème, et la manière dont nous allons faire
cela dans cette partie du tutoriel est toujours sûre.

p. Essentiellement nous allons annuler le commit en créant un nouveau commit qui
invers les changements non voulus.

h2. Changer le fichier et le commiter.

p. Changer le fichier @hello.rb@ de la manière suivante.

File: hello.rb
# This is an unwanted but committed change
name = ARGV.first || "World"

puts "Hello, #{name}!"
EOF

Execute:
git add hello.rb
git commit -m "Oops, we didn't want this commit"

h2. Créer un commit de retour en arrière

p. Pour annuler un changement commité, nous avons besoin de générer un commit
qui enlève les changements introduits par notre commit non voulu.

Execute:
-git revert HEAD
+git revert HEAD --no-edit
=revert

p. Cela va vous ouvrir votre éditeur de texte. Vous pouvez éditer le message
de commit par défaut ou le laisser tel quel. Sauver et fermer le fichier.
Vous devriez voir ...

Output:
=revert
EOF

p. Comme nous étions en train d'annuler le dernier commit que nous avions
fait, nous avons été capable d'utiliser @HEAD@ comme argument pour annuler.
Nous pouvons annuler n'importe quel commit de manière arbitraire plus ancien
dans l'historique en spécifiant simplement la valeur de son hash.

p(note). *Note:* Le @--no-edit@ dans la sortie peut être ignoré.
Il était nécessaire de générer la sortie sans ouvrir l'éditeur.

h2. Vérifier le log

p. Vérifier que le log montre à la fois les commits non désirés et ceux
de correction des commits non désirés dans notre répertoire.

Execute:
git hist
=hist

Output:
=hist
EOF

p. Cette technique fonctionnera avec n'importe quel commit (même si vous allez
peut être devoir résoudre des conflits). C'est sûr pour être utilisé même sur
les branches qui sont partagées sur des dépôts distants.

h2. Quoi de plus

p. Maintenant, allons regarder une technique qui peut être utilisée pour enlever
les commits les plus récents de l'historique du dépôt.

----------------------------------------------------------------------
h1. Enlever des commits d'une branche

h3. Buts

* Apprendre comment enlever les commits les plus récents d'une branche

p. La commande @revert@ de la section précédente est une commande puissante
qui nous laisse défaire les effets de d'importe quel commit dans le dépôt.
Cependant, à la fois le commit original et celui qui l'annule sont visibles
dans l'historique de la branche (en utilisant la commande @git log@).

p. Souvent, nous faisons un commit et réalisons immédiatement que nous avons
commis une erreur. Il pourrait être pratique d'avoir une commande de retour
en arrière qui nous permette de faire comme si le mauvais commit n'avait jamais
été fait. Cette commande de retour en arrière devrait aussi pouvoir prévenir
que le mauvais commit apparaisse dans l'historique de la commande @git log@.
Ce serait comme si le mauvais commit n'avait jamais existé.

h2. La commande @reset@

p. Nous avons déjà vue la commande @reset@ et l'avons utilisé pour garder les
fichiers en attente consistants  avec un commit donné(nous avons utilisé le
commit HEAD dans la précédente partie).

p. Quand nous donnons la référence d'un commit (comme un hash, une branche ou
nom de tag), la commande @reset@ va ...

# Réécrire la branche courante jusqu'au point du commit spécifié
# De manière optionnelle, réinitialiser la liste des fichiers en attente pour
correspondre au commit spécifié
# De manière optionnelle, réinitialiser le répertoire de travail pour
correspondre au commit spécifié

h2. Vérifions notre historique

p. Faisons une petite vérification de de notre historique de commit.

Execute:
git hist
=hist

Output:
=hist
EOF

p. Nous voyons que nous avons un commit "Oops" et un commit "Revert Oops"
comme deux derniers commits fait dans cette branche. Maintenant enlevons-les
en utilisant reset.

h2. En premier, marquer cette branche

p. mais avant d'enlever les commits, marquons le dernier commit avec
un tag pour que nous puissions encore le retrouver.

Execute:
git tag oops

h2. Réinitialiser à Before Oops

p. En regardant àl'historique de log (au dessus), nous voyions que le commit
taggé 'v1' est le commit juste avant le mauvais commit. Commençons par
réinitialiser la branche à ce point. A présent que cette branche est taggé,
nous pouvons utiliser le nom du tag dans la commande reset (si elle ne
l'était pas, nous pourrions juste utiliser la valeur de hash).

Execute:
git reset --hard v1
=reset
git hist
=hist2

Output:
=reset
=hist2
EOF

p. Our master branch now points to the v1 commit and the Oops commit
and the Revert Oops commit are no longer in the branch.  The @--hard@
parameter indicates that the working directory should be updated to be
consistent with the new branch head.

h2. Rien n'est jamais perdu

p. Mais qu'est il arrivé aux mauvais commits? En fait les commits sont
toujours dans le dépôt. D'ailleurs, nous pouvons toujours les référencer.
Rappelez vous qu'au début de cette partie, nous avons taggé le commit
d'annulation avec le tag "oops". Regardons _tous_ les commits.

Execute:
git hist --all
=hist3

Output:
=hist3
EOF

p. Ici nous voyons que les mauvais commits n'ont pas disparus. Ils sont
toujours dans le dépôt. C'est juste qu'ils ne sont plus listés dans la
branche master. Si nous ne les avions pas taggés, ils seraient toujours
dans le dépôt, mais il n'y aurait plus moyen de les référencer autrement
que par leur nom de hash. Les commits non référencés restent dans le dépôt
jusqu'à ce que le système lance l'utilitaire de nettoyage mémoire.

h2. Les dangers du reset

p. Les réinitialisations sur les branches locales sont généralement sûres.
N'importe quel accident peut être généralement récupéré en faisant un reset
avec le commit désiré.

p. Cependant, si la branche est partagée sur des répertoires distants, faire
un reste peut gêner les autres utilisateurs de la branche.

----------------------------------------------------------------------
h1. Enlever le tag oops

h3. Buts

* Enlever le tag oops (pour faire le ménage)

h2. Enlever le tag oops

p. Le tag oops a atteint son but. Enlevons-le et permettons aux commits
qu'il référence d'être nettoyer.

Execute:
git tag -d oops
=tag
git hist --all
=hist

Output:
=tag
=hist
EOF

p. Le tag oops est désormais plus listé dans le dépôt.

----------------------------------------------------------------------
h1. Amender les commits

h3. Buts

* APprendre comment amender un commit existant

h2. Changer le programme puis commiter

p. Ajouter un commentaire de l'auteur au programme.

File: hello.rb
# Default is World
# Author: Jim Weirich
name = ARGV.first || "World"

puts "Hello, #{name}!"
EOF

Execute:
git add hello.rb
git commit -m "Add an author comment"

h2. Ah, une erreur, il faudrait un email

p. Après avoir fait le commit, vous réalisez  que n'importe quel bon commentaire
devrait avoir un email inclus. Mettre à jour le programme hello pour inclure un
email.

File: hello.rb
# Default is World
# Author: Jim Weirich (jim@somewhere.com)
name = ARGV.first || "World"

puts "Hello, #{name}!"
EOF

h2. Amender le commit précédent

p. Nous ne voulons vraiment pas un commit séparé juste pour l'email.
Amendons le commit précédent pour inclure le changement d'email.

Execute:
git add hello.rb
=add
git commit --amend -m "Add an author/email comment"
=commit

Output:
=add
=commit
EOF


h2. Vérifier l'historique

Execute:
git hist
=hist

Output:
=hist
EOF

p. Nous pouvons voir que le commit original "auteur" est parti, et qu'il
est remplacé par le commit "auteur/email". Vous pouvez obtenir le même
effet en réinitialisant la branche d'un commit puis recommiter les
nouveaux changements.

----------------------------------------------------------------------
h1. Déplacer les fichiers

h3. Buts

* Apprendre comment bouger un fichier dans un dépôt.

h2. Bougerle fichier hello.rb dans un répertoire lib.

p. Nous allons maintenant construire la structure de notre petit
dépôt. Bougeons le programme dans un répertoire lib.

Execute:
mkdir lib
=mkdir
git mv hello.rb lib
=move
!git status
=status

Output:
=mkdir
=move
=status
EOF

p. En utilisant git pour effectuer le déplacement, nous informons git de 2 choses

# Que le fichier @hello.rb@ a été supprimé.
# Que le fichier @lib/hello.rb@ a été créé.

p. Ces deux informations ont  immédiatement été ajoutées dans la liste des fichiers
en attente et sont prêtes à être commitées. La commande git status renvoie que le
fichier a été déplacé.

h2. Une autre manière de bouger des fichiers

p. Une des choses agréable de git est que vous pouvez oublier le contrôle des
sources jusqu'à ce que vous soyez prêt à commiter le code.
Que ce passerait-t-il si nous utilisons les commandes du système d'exploitation
pour bouger le fichier plutôt que la commande git?

p. La suite de commandes suivante équivaut à ce que nous venons de faire.
C'est un peu plus de travail mais le résultat est identique.

p(command). Nous aurions pu faire:

pre(instructions). mkdir lib
mv hello.rb lib
git add lib/hello.rb
git rm hello.rb

h2. Commiter le nouveau dossier

p. Commitons ce déplacement.

Execute:
git commit -m "Moved hello.rb to lib"

----------------------------------------------------------------------
h1. Plus de structuration

h3. Buts

* Ajouter un autre fichier à notre dépôt

h2. Maintenant ajoutons un fichier Rakefile

p. Ajoutons un fichier Rakefile à notre dépôt. Ce qui suit convient
parfaitement pour cela.

File: Rakefile
#!/usr/bin/ruby -wKU

task :default => :run

task :run do
  require './lib/hello'
end
EOF

p. Ajouter et commiter le changement.

Execute:
git add Rakefile
git commit -m "Added a Rakefile."

p. Vous devriez maintenant être capable d'utiliser rake pour lancer
votre programme hello.

Execute:
rake
=rake

Output:
=rake
EOF

----------------------------------------------------------------------
h1. Fonctionnement interne de Git: le répertoire .git

h3. Buts

* Apprendre la structure du répertoire @.git@

h2. Le répertoire @.git@

p. C'est le moment de faire une petite exploration. En premier, depuis la racine
de votre répertoire de projet...

Execute:
ls -C .git
=lsgit

Output:
=lsgit
EOF

p. C'est le répertoire magique où les "trucs" de git sont stockés.
Allons jeter un oeil dans le répertoire des objets.

h2. Le magasin d'objets

Execute:
ls -C .git/objects
=lsobjs

Output:
=lsobjs
EOF

p. Vous devriez voir un ensemble de répertoires avec des noms de 2 lettres. Les
noms des répertoires sont les deux premières lettres du hash sha1 de l'objet
stocké dans git.

h2. Approfondissement sur le magasin d'objets

Set: dir=`ls .git/objects | head -1`.strip
Execute:
ls -C .git/objects/<dir>
=lsobjs2

Output:
=lsobjs2
EOF

p. Ragradez dans l'un des répertoires à deux lettres. Vous devriez voir
quelques fichiers avec des noms de 38 caractères. Ce sont les fichiers
qui contiennent les objets stockés dans git. Ces fichiers sont compressés
et encodés, ainsi regardez à leur contenu directement ne sera pas très utile,
mais nous allons jeter un oeil plus attentif d'ici peu.

h2. Le fichier config

Execute:
cat .git/config
=cat

Output:
=cat
EOF

p. C'est un fichier de configuration propre au projet. Les entrées ici
vont supplémenter les entrées de configuration dans le fichier @.gitconfig@
de votre répertoire personnel(home), du moins pour ce projet.

h2. Branches et tags

Execute:
ls .git/refs
=refs
ls .git/refs/heads
=refhead
ls .git/refs/tags
=reftags
cat .git/refs/tags/v1
=refv1

Output:
=refhead
=refs
=reftags
=refv1
EOF

p. Vous devriez reconnaître les fichiers dans le sous-répertoire des tags.
Chaque fichier correspond à un tag que vous avez créé avec la commande @git tag@
un peu plus tôt. Son contenu est juste le hash du commit associé au tag.

p. Le répertoire heads est similaire, mais est utilisé par les branches plutôt
que les tags. Nous avons seulement une branche pour le moment, ainsi tout ce que
verrez dans ce répertoire est master.

h2. Le fichier HEAD

Execute:
cat .git/HEAD
=head

Output:
=head
EOF

p. Le fichier HEAD contient une référence à la branche courante. Cela
devrait être une référence à master pour le moment.

----------------------------------------------------------------------
h1. Fonctionnement interne de Git: travailler directement avec les objets Git

h3. Buts

* Explorer la structure du magasin d'objets
* Apprendre comment utiliser les hashes SHA1 pour trouver le contenu dans
le dépôt

p. Maintenant utilisons quelques outils pour analyser directement les objets git.

h2. Trouver le dernier commit

Execute:
git hist --max-count=1
=log

p. Cela devrait montrer le dernier commit fait dans le dépôt. Le hash
SHA1 sur votre système est probablement différent de ce lui qui est chez nous,
mais vous devriez voir quelque chose de ce type.

Output:
=log
EOF

h2. Extraire les infos du dernier commit

Utiliser le hash SHA1 depuis le commit listé ci-dessus ...

Set: hash=hash_for("Added a Rakefile")
Execute:
git cat-file -t <hash>
=type
git cat-file -p <hash>
=dump

Voici notre sortie ...

Output:
=type
=dump
EOF

p(note). *NOTE:* If you defined the 'type' and 'dump' aliases from
the aliases lab, then you can type @git type@ and @git dump@ rather
than the longer cat-file commands (which I never remember).

p. This is the dump of the commit object that is at the head of the
master branch.  It looks a lot like the commit object from the
presentation earlier.

h2. Finding the Tree

p. We can dump the directory tree referenced in the commit.  This
should be a description of the (top level) files in our project (for
that commit).  Use the SHA1 hash from the "tree" line listed above.

Set: treehash=hash_in(var['hash'], 'tree')
Execute:
git cat-file -p <treehash>
=treedump

p. Here's what my tree looks like...

Output:
=treedump
EOF

p. Yep, I see the Rakefile and the lib directory.

h2. Dumping the lib directory

Set: libhash=hash_in(var['treehash'], 'lib')
Execute:
git cat-file -p <libhash>
=libdump

Output:
=libdump
EOF

p. There's the @hello.rb@ file.

h2. Dumping the @hello.rb@ file

Set: rbhash=hash_in(var['libhash'], 'hello')
Execute:
git cat-file -p <rbhash>
=rbdump

Output:
=rbdump
EOF

p. There you have it.  We've dumped commit objects, tree objects and
blob objects directly from the git repository.  That's all there is to
it, blobs, trees and commits.

h2. Explore On You Own

p. Explore the git repo manually on your own.  See if you can find the
original hello.rb file from the very first commit by manually
following the SHA1 hash references starting in the latest commit.

----------------------------------------------------------------------
h1. Creating a Branch

h3. Goals

* Learn how to create a local branch in a repository

p. It's time to do a major rewrite of the hello world functionality.
Since this might take awhile, you'll want to put these changes into a
separate branch to isolate them from changes in master.

h2. Create a Branch

p. Let's call our new branch 'greet'.

Execute:
git checkout -b greet
!git status

p(note). *NOTE:* @git checkout -b <branchname>@ is a shortcut for @git
branch <branchname>@ followed by a @git checkout <branchname>@.

p. Notice that the git status command reports that you are on the
'greet' branch.

h2. Changes for Greet: Add a Greeter class.

File: lib/greeter.rb
class Greeter
  def initialize(who)
    @who = who
  end
  def greet
    "Hello, #{@who}"
  end
end
EOF

Execute:
git add lib/greeter.rb
git commit -m "Added greeter class"

h2. Changes for Greet: Modify the main program

p. Update the hello.rb file to use greeter

File: lib/hello.rb
require 'greeter'

# Default is World
name = ARGV.first || "World"

greeter = Greeter.new(name)
puts greeter.greet
EOF

Execute:
git add lib/hello.rb
git commit -m "Hello uses Greeter"

h2. Changes for Greet: Update the Rakefile

p. Update the Rakefile to use an external ruby process

File: Rakefile
#!/usr/bin/ruby -wKU

task :default => :run

task :run do
  ruby '-Ilib', 'lib/hello.rb'
end
EOF

Execute:
git add Rakefile
git commit -m "Updated Rakefile"

h2. Up Next

p. We now have a new branch called *greet* with 3 new commits on it.
Next we will learn how to navigate and switch between branches.

----------------------------------------------------------------------
h1. Navigating Branches

h3. Goals

* Learn how to navigate between the branches of a repository

p. You now have two branches in your project:

Execute:
git hist --all
=log

Output:
=log
EOF

h2. Switch to the Master Branch

p. Just use the @git checkout@ command to switch between branches.

Execute:
git checkout master
=checkout
cat lib/hello.rb
=cat

Output:
=checkout
=cat
EOF

p. You are now on the master branch.  You can tell because the
hello.rb file doesn't use the @Greeter@ class.

h2. Switch Back to the Greet Branch.

Execute:
git checkout greet
=checkout2
cat lib/hello.rb
=cat2

Output:
=checkout2
=cat2
EOF

p. The contents of the @lib/hello.rb@ confirms we are back on the
*greet* branch.

----------------------------------------------------------------------
h1. Changes in Master

h3. Goals

* Learning how to deal with multiple branches with different (and possibly conflicting) changes.

p. While you were changing the greet branch, someone else decided to
update the master branch.  They added a README.

h2. Switch to the master branch.

Execute:
git checkout master

h2. Create the README.

File: README
This is the Hello World example from the git tutorial.
EOF

h2. Commit the README to master.

Execute:
git add README
git commit -m "Added README"

----------------------------------------------------------------------
h1. Viewing Diverging Branches

h3. Goals

* Learn how to view diverging branches in a repository.

h2. View the Current Branches

p. We now have two diverging branches in the repository.  Use the
following log command to view the branches and how they diverge.

Execute:
git hist --all
=log

Output:
=log
EOF

p. Here is our first chance to see the @--graph@ option on @git hist@ in
action. Adding the @--graph@ option to @git log@ causes it to draw the
commit tree using simple ASCII characters.  We can see both branches
(greet and master), and that the master branch is the current HEAD.
The common ancestor to both branches is the "Added a Rakefile" branch.

p. The @--all@ flag makes sure that we see all the branches.  The
default is to show only the current branch.

----------------------------------------------------------------------
h1. Merging

h3. Goals

* Learn how to merge two diverging branches to bring the changes back into a single branch.

h2. Merge the branches

p. Merging brings the changes in two branches together.  Let's go back
to the greet branch and merge master onto greet.

Execute:
git checkout greet
=checkout
git merge master
=merge
git hist --all
=hist

Output:
=checkout
=merge
=hist
EOF

p. By merging master into your greet branch periodically, you can pick
up any changes to master and keep your changes in greet compatible
with changes in the mainline.

p. However, it does produce ugly commit graphs. Latter we will look at
the option of rebasing rather than merging.

h2. Up Next

p. But first, what if the changes in master conflict with the changes
in greet?

----------------------------------------------------------------------
h1. Creating a Conflict

h3. Goals

* Create a conflicting change in the master branch.

h2. Switch back to master and create a conflict

p. Switch back to the master branch and make this change:

Execute:
git checkout master

File: lib/hello.rb
puts "What's your name"
my_name = gets.strip

puts "Hello, #{my_name}!"
EOF

Execute:
git add lib/hello.rb
git commit -m "Made interactive"

h2. View the Branches

Execute:
git hist --all
=log

Output:
=log
EOF

p. Master at commit "Added README" has been merged to the greet
branch, but there is now an additional commit on master that has not
been merged back to greet.

h2. Up Next

p. The latest change in master conflicts with some existing changes in
greet.  Next we will resolve those changes.

----------------------------------------------------------------------
h1. Resolving Conflicts

h3. Goals

* Learn how to handle conflicts during a merge

h2. Merge master to greet

p. Now go back to the greet branch and try to merge the new master.

Execute:
git checkout greet
!git merge master

Output:
$ git checkout greet
Switched to branch 'greet'
$ git merge master
Auto-merging lib/hello.rb
CONFLICT (content): Merge conflict in lib/hello.rb
Automatic merge failed; fix conflicts and then commit the result.
EOF

If you open lib/hello.rb, you will see:

file: lib/hello.rb
<<<<<<< HEAD
require 'greeter'

# Default is World
name = ARGV.first || "World"

greeter = Greeter.new(name)
puts greeter.greet
=======
# Default is World

puts "What's your name"
my_name = gets.strip

puts "Hello, #{my_name}!"
>>>>>>> master
EOF

p. The first section is the version on the head of the current branch
(greet).  The second section is the version on the master branch.

h2. Fix the Conflict

p. You need to manually resolve the conflict.  Modify @lib/hello.rb@
to be the following.

File: lib/hello.rb
require 'greeter'

puts "What's your name"
my_name = gets.strip

greeter = Greeter.new(my_name)
puts greeter.greet
EOF

h2. Commit the Conflict Resolution

Execute:
git add lib/hello.rb
=add
git commit -m "Merged master fixed conflict."
=commit

Output:
=add
=commit
EOF

h2. Advanced Merging

p. git doesn't provide any graphical merge tools, but it will gladly
work with any third party merge tool you wish to use.  See
"http://onestepback.org/index.cgi/Tech/Git/UsingP4MergeWithGit.red":http://onestepback.org/index.cgi/Tech/Git/UsingP4MergeWithGit.red
for a description of using the Perforce merge tool with git.

----------------------------------------------------------------------
h1. Rebasing VS Merging

h3. Goals

* Learn the differences between rebasing and merging.

h3. Discussion

p. Let's explore the differences between merging and rebasing.  In
order to do so, we need to rewind the repository back in time before
the first merge, and then redo the same steps, but using rebasing
rather than merging.

p. We will make use the of the @reset@ command to wind the branches
back in time.

----------------------------------------------------------------------
h1. Resetting the Greet Branch

h3. Goals

* Reset the greet branch to the point before the first merge.

h2. Reset the greet branch

p. Let's go back in time on the greet branch to the point _before_ we
merged master onto it.  We can *reset* a branch to any commit we want.
Essentially this is modifying the branch pointer to point to anywhere
in the commit tree.

p. In this case we want to back greet up to the point prior to the
merge with master.  We need to find the last commit before the merge.

Execute:
git checkout greet
=checkout
git hist
=log

Output:
=checkout
=log
EOF

p. That's a bit hard to read, but looking at the data we see that the
"Updated Rakefile" commit was the last commit on the greet branch
before merging.  Let's reset the greet branch to that commit.

Set: hash=hash_for("Updated Rakefile")
Execute:
git reset --hard <hash>
=reset

Output:
=reset
EOF

h2. Check the branch.

p. Look at the log for the greet branch.  We no longer have the merge
commits in its history.

Execute:
git hist --all
=log2

Output:
=log2
EOF

----------------------------------------------------------------------
h1. Resetting the Master Branch

h3. Goals

* Reset the master branch to the point before the conflicting commit.

h2. Reset the master branch

p. When we added the interactive mode to the master branch, we made a
change that conflicted with changes in the greet branch. Let's rewind
the master branch to a point before the conflicting change.  This
allows us to demonstrate the rebase command without worrying about
conflicts.

Execute:
git checkout master
git hist
=log

Output:
=log
EOF

p. The 'Added README' commit is the one directly before the
conflicting interactive mode.  We will reset the master branch to
'Added README' branch.

Set: hash=hash_for("Added README")
Execute:
git reset --hard <hash>
git hist --all
=log2

p. Review the log.  It should look like the repository has been wound
back in time to the point before we merged anything.

Output:
=log2
EOF

----------------------------------------------------------------------
h1. Rebasing

h3. Goals

* Use the rebase command rather than the merge command.

p. Ok, we are back in time before the first merge and we want to get
the changes in master into our greet branch.

p. This time we will use the rebase command instead of the merge
command to bring in the changes from the master branch.

Execute:
git checkout greet
git rebase master
git hist
=log

Output:
$ go greet
Switched to branch 'greet'
$
$ git rebase master
First, rewinding head to replay your work on top of it...
Applying: added Greeter class
Applying: hello uses Greeter
Applying: updated Rakefile
$
=log
EOF

h2. Merge VS Rebase

p. The final result of the rebase is very similar to the merge.  The
greet branch now contains all of its changes, as well as all the
changes from the master branch.  However, the commit tree is quite
different.  The commit tree for the greet branch has been rewritten so
that the master branch is a part of the commit history.  This leaves
the chain of commits linear and much easier to read.

h2. When to Rebase, When to Merge?

p. Don't use rebase ...

# If the branch is public and shared with others.  Rewriting publicly shared branches will tend to screw up other members of the team.
# When the _exact_ history of the commit branch is important (since rebase rewrites the commit history).

p. Given the above guidelines, I tend to use rebase for short-lived,
local branches and merge for branches in the public repository.

----------------------------------------------------------------------
h1. Merging Back to Master

h3. Goals

* We've kept our greet branch up to date with master (via rebase), now let's merge the greet changes back into the master branch.

h2. Merge greet into master

Execute:
git checkout master
git merge greet
=merge

Output:
$ git checkout master
Switched to branch 'master'
$
=merge
EOF

p. Because the head of master is a direct ancestor of the head of the
greet branch, git is able to do a fast-forward merge.  When
fast-forwarding, the branch pointer is simply moved forward to point
to the same commit as the greeter branch.

p. There will never be conflicts in a fast-forward merge.

h2. Review the logs

Execute:
git hist
=log

Output:
=log
EOF

p. The greet and master branches are now identical.

----------------------------------------------------------------------
h1. Multiple Repositories

p. Up to this point we have been working with a single git repository.
However, git excels at working with multiple repositories.  These
extra repositories may be stored locally, or may be accessed across a
network connection.

p. In the next section we will create a new repository called
"cloned_hello".  We will show how to move changes from one repository
to another, and how to handle conflicts when they arise from between
two repositories.

 !git_clone.png!


p. For now, we will be working with local repositories
(i.e. repositories stored on your local hard disk), however most of
the things learned in this section will apply to multiple repositories
whether they are stored locally or remotely over a network.

p. *NOTE:* We are going be making changes to both copies of our
repositories.  Make sure you pay attention to which repository you are
in at each step of the following labs.

----------------------------------------------------------------------
h1. Cloner des dépôts

h3. Buts

* Apprendre comment faire des copies des dépôts.

h2. Aller au répertoire de travail

p. Aller au répertoire de travail et faire un clone de votre dépôt hello.

Execute:
cd ..
=cd
pwd
=pwd
ls
=ls

p{color:red}. *NOTE: Maintenant dans le répertoire de travail.*

Output:
=cd
=pwd
=ls
EOF

p. A ce stade vous devriez être dans le répertoire "work". Il devrait
avoir un seul dépôt ici nommé "hello".

h2. Créer un clone du dépôt hello

p. Faisons un clone du dépôt.

Execute:
git clone hello cloned_hello
=clone
ls
=ls2
+cd cloned_hello
+git config user.name "Jim Weirich"
+git config user.email "jim (at) edgecase.com"
+cd ..

Output:
=clone
=ls2
EOF

p. Il devrait maintenant y avoir deux dépôts dans votre répertoire de
travail: le dépôt original "hello" et le nouveau dépôt cloné "cloned_hello".

----------------------------------------------------------------------
h1. Examiner le dépôt cloné

h3. Buts

* Apprendre à propos des branches sur les dépôts distants.

h2. Jetons un oeil au dépôt cloné

p. Regardons un peu le dépôt cloné.

Execute:
cd cloned_hello
=cd
ls
=ls

Output:
=cd
=ls
EOF

p. Vous devriez voir une liste de tous les fichiers au niveau supérieur de votre
dépôt original (@README@, @Rakefile@ et @lib@).


h2. Examiner l'historique du dépôt

Execute:
git hist --all
=log

Output:
=log
EOF

p. Vous devriez maintenant voir une liste de tous les commits dans le
nouveau dépôt, et il devrait (plus ou moins) correspondre à l'historique
commits dans le dépôt original. La seule différence devrait être dans le
nom des branches.

h2. Branches distantes

p. Vous devriez voir une branche *master* (avec *HEAD*) dans la liste
d'historique. Mais vous allez voir aussi nombres de branches nommées
étrangement (*origin/master*, *origin/greet* et *origin/HEAD*). Nous
allons les voir sous peu.

----------------------------------------------------------------------
h1. Qu'est ce qu'origin?

h3. Buts

* Apprendre à propos du nommage des dépôts distants.

Execute:
git remote
=remote

Output:
=remote
EOF

p. Nous voyons que le dépôt cloné connait un dépôt distant nommé origin.
Voyons ce que si nous pouvons avoir plus d'informations sur origin:

Execute:
git remote show origin
=show

Output:
=show
EOF

p. Maintenant, nous voyons que le dépôt distant "origin"est simplement le
dépôt original *hello*. Les dépôts distants vivent typiquement sur une
machine séparée, de manière possible aussi sur une serveur centralisé.
Comme nous le voyons ici, cependant, ils peuvent aussi pointer vers un
répertoire sur la même machine.
Il n'y a rien de particulier à propos du nom "origin", cependant la
convention est d'utiliser le nom "origin" pour le nom du dépôt centralisé
primaire (s'il y en a un).

----------------------------------------------------------------------
h1. Branches distantes

h3. Buts

* Apprendre les différences entre branches locales VS branches distantes

p. Regardons dans les branches disponibles dans notre dépôt cloné.

Execute:
git branch
=branch

Output:
=branch
EOF

p. C'est ça, seule la  branche master est listée. Où est la branche greet
? La commande *git* *branch* liste seulement les branches locales par
défaut.

h2. Lister les branches distantes

p. Essayer ceci pour voir toutes les branches:

Execute:
git branch -a
=branch_a

Output:
=branch_a
EOF

p. Git a tous les commits du dépôt original, mais les branches
dans le dépôt distant ne sont pas traitées comme des branches locales ici.
Si nous voulons notre propre branche *greet*, nous devons la créer nous-même.
Nous allons voir comment faire cela dans une minute.

----------------------------------------------------------------------
h1. Changer le dépôt original

h3. Buts

* Faire quelques changements au dépôt original afin que nous puissions
récupérer les changements

h2. Faire un changement dans le dépôt original *hello*

Execute:
cd ../hello
+pwd
# (Vous devriez maintenant être dans le dépôt original hello maintenant)

p{color:red}. *NOTE: Maintanant dans le dépôt _hello_*

p. Faire les changements suivants à README:

File: README
This is the Hello World example from the git tutorial.
(changed in original)
EOF

p. Maintenant ajouter et commiter ce changement

Execute:
git add README
git commit -m "Changed README in original repo"

h2. Après

p. Le dépôt original maintenant a des changements tardifs qui ne sont
pas dans la version clonée. Ensuite, nous allons récupérer ces changements
dans le dépôt cloné.

----------------------------------------------------------------------
h1. Rapporter(fetch) les changements

h3. Buts

* Apprendre comment rapporte les changements depuis un dépôt distant.

Execute:
cd ../cloned_hello
+pwd
git fetch
=fetch
git hist --all
=hist

p{color:red}. *NOTE: Maintenant dans le dépôt _cloned_hello_*

Output:
=fetch
=hist
EOF

p. Actuellement le dépôt a tous les commits provenant de celui
original, mais ils ne sont pas intégrés dans les branches locales
du dépôt cloné.

p. Trouver le commit "Changed README in original repo" dans l'historique
ci-dessus. Notez que le commit inclut "origin/master" et "origin/HEAD".

p. Maintenant regardez dans le commit "Updated Rakefile". Vous allez voir
que sa branche locale master pointe vers ce commit, pas vers le nouveau commit
que nous venons juste de rapporter.

p. Le résultat de ceci est que la commande "git fetch" va maintenant rapporter
les nouveaux commits du dépôt distant, mais qu'elle ne va pas fusionner ces
commits dans les branches locales.

h2. Vérifier le fichier README

Nous pouvons démontrer que le README cloné est inchangé.

Execute:
cat README

Output:
$ cat README
This is the Hello World example from the git tutorial.
EOF

p. Voyez, pas de changements.

----------------------------------------------------------------------
h1. Fusionner les changements récupérés

h3. Buts

* Apprendre comment récupérer les changements récupérés dans la branche
courante et dans le répertoire de travail.

h2. Fusionner les changements récupérés dans la branche master locale

Execute:
git merge origin/master
=merge

Output:
=merge
EOF

h2. Vérfier le fichier README à nouveau

p. Nous devrions voir les changements maintenant.

Execute:
cat README

Output:
$ cat README
This is the Hello World example from the git tutorial.
(changed in original)
EOF

p. Il y a les changements. Même si "git fetch" ne fusionne pas les
changements, nous pouvons toujours manuellement les fusionner depuis
le dépôt distant.

h2. Ensuite

p. Après regardons comme combiner le processus fetch et merge dans
une seule commande.

----------------------------------------------------------------------
h1. "Tirer" (pull) les changements

h3. Buts

* Apprendre que @git pull@ est équivalent à un @git fetch@ suivi par un @git merge@.

h3. Discussion

p. Nous n'allons pas repasser tout le processus de création d'un autre
changement et le récupérer encore, mais nous voulons que vous sachiez
que faire:

pre(instructions). git pull

est en fait équivalent à ces deux étapes:

pre(instructions). git fetch
git merge origin/master

----------------------------------------------------------------------
h1. Ajouter une branche pour le suivi

h3. Buts

* Apprendre comment ajouter une branche locale qui suit une branche distante.

p. Les branches qui commencent avec remotes/origin sont les branches
du dépôt original. Notez que nous n'avons plus une branche appelée greet,
mais git sait que le dépôt original has une branche greet.

h2. Ajouter une branche locale qui permet de suivre une branche distante.

Execute:
git branch --track greet origin/greet
=branch_track
git branch -a
=branch_a
git hist --max-count=2
=log

Output:
=branch_track
=branch_a
=log
EOF

p. Nous pouvons maintenant voir que la branche greet dans la liste des
branches et dans le log.

----------------------------------------------------------------------
h1. Dépôts dit "nus" (bare)

h3. Buts

* Apprendre comment créer des dépôts dit "nus" (bare).

p. Les dépôts dit "nus" (sans répertoires de travail) sont généralement
utilisés pour être partagés.

h2. Créer un dépôt "nu".

Execute:
cd ..
+pwd
git clone --bare hello hello.git
=clone
ls hello.git
=ls

p{color:red}. *NOTE: Maintenant dans le répertoire de travail*

Output:
=clone
=ls
EOF

p. La convention est que les dépôts finissant avec '.git' sont des
dépôts "nus". Nous pouvons voir qu'il n'y a pas de répertoire de travail
dans le dépôt hello.git. C'est essentiellement rien de plus que le
répertoire .git d'un dépôt non "nu".

----------------------------------------------------------------------
h1. Ajouter un dépôt distant

h3. Buts

* Ajouter le dépôt dit "nu" (bare) comme distant par rapport à notre
dépôt d'origine.

p. Ajoutons le dépôt hello.git à notre dépôt d'origine.

Execute:
cd hello
+pwd
git remote add shared ../hello.git

p{color:red}. *NOTE: Maintenant dans le dépôt +hello+.*

----------------------------------------------------------------------
h1. Envoyer un changement

h3. Buts

* Apprendre comment envoyer un changement vers un dépôt distant.

p. Comme les dépôts dit "nus" sont habituellement partagé sur une sorte
de serveur réseau, il est difficile de se rendre dans le dépôt et de récupérer.
les changements. Ainsi nous avons besoins d'envoyer nos changements dans les
autres dépôts.

p. Commençons par créer un changement à envoyer. Editer le fichier README
et le commiter

File: README
This is the Hello World example from the git tutorial.
(Changed in the original and pushed to shared)
EOF

Execute:
git checkout master
git add README
git commit -m "Added shared comment to readme"

p. Maintenant envoyer le changement à notre dépôt partagé.

Execute:
git push shared master
=push

p. _shared_ est le nom du dépôt qui reçoit les changements que nous
envoyons. (Souvenez vous, nous l'avons ajouté comme distant dans la
précédente partie du tutoriel.)

Output:
=push
EOF

p(note). *NOTE:* Nous devons explicitement nommé la branche master qui
devra recevoir l'envoi. Il est possible de le configurer automatiquement,
mais je ne me souviens _jamais_ des commandes pour le faire.
Regarder le fichier gem "Git Remote Branch" pour une gestion facile
des branches distantes.

----------------------------------------------------------------------
h1. Récupérer les changements partagés

h3. Buts

* Apprendre comment récupérer les changements depuis un dépôt partagé.

p. Aller rapidement dans le clône du dépôt et maintenant récupérons rapidement
les changements qu'on vient juste d'effectuer sur le dépôt partagé.

Execute:
cd ../cloned_hello
+pwd

p{color:red}. *NOTE: Maintenant dans le dépôt _cloned_hello_.*

p. Continuer avec ...

Execute:
git remote add shared ../hello.git
git branch --track shared master
git pull shared master
cat README

----------------------------------------------------------------------
h1. Héberger vos dépôts Git

h3. Buts

* Apprendre comment configurer un serveur git pour partager des dépôts.

p. Il y a de nombreux moyens de partager des dépôts git via un réseau.
Voici une méthode rapide et pas "très propre".

h2. Démarrer le serveur git

execute:
# (Depuis le répertoire de travail)
git daemon --verbose --export-all --base-path=.

p. Maintenant, dans une fenêtre de terminal séparée, aller au répertoire de travail

execute:
# (From the work directory)
git clone git://localhost/hello.git network_hello
cd network_hello
ls

p. Vous devriez voir une copie du projet hello.

h2. Envoyer vers le démon Git

p. Si vous voulez pouvoir pousser vers le dépôt du démon git, ajouter
@--enable=receive-pack@ à la commande du démon git. Faites attention parce
qu'il n'y a pas d'authentification sur le serveur, n'importe qui peut
pousser vers votre dépôt.

----------------------------------------------------------------------
h1. Partager des dépôts

h3. Buts

* Apprendre comment partager un dépôt via le WIFI.

p. Voir si votre voisin fait tourner une "démon" git. Echanger les
addresses IP et voir si vous pouvez récupérer chacun le dépôt de l'autre.

p(note). *NOTE:* Le gem gitjour est très pratique pour partager
des dépôts ad-hoc.

----------------------------------------------------------------------
h1. Sujets avancés / futurs

p. Voici quelques un des sujets que vous pourriez souhaiter regarder
par vous même:

* Annulation des changements commités
* Fin de lignes pour les différents systèmes d'exploitation
* Serveurs distants
* Protocoles
* Paramétrage SSH
* Gestion de branche à distance
* Recherche des commits buggés (git bisect)
* Chaînes de traitement
* Outils graphiques (gitx, gitk, magit)
* Usage avec GitHub

----------------------------------------------------------------------
h1. Merci

p. Merci d'avoir essayé le tutoriel Git Immersion. Libre à vous de prendre
contact avec l'auteur original (anglophone) à l'adresse jim.weirich@gmail.com
ou pour des remarques sur la traduction à thomas_gratier@yahoo.fr

